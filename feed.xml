<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://dev-happy.com/' rel='self' type='application/rss+xml'/>
<title>
Dev Happy
</title>
<link>
http://dev-happy.com/
</link>
<description>
개발 관련 경험 및 성찰들을 기록
</description>
<lastBuildDate>
Wed, 04 Dec 2019 06:07:26 +0900
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
http://dev-happy.com/posts/2019-12-04-4clojure-61.html
</guid>
<link>
http://dev-happy.com/posts/2019-12-04-4clojure-61.html
</link>
<title>
4clojure - Map Construction (61)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;:a :b :c&amp;#93; &amp;#91;1 2 3&amp;#93;&amp;#41; {:a 1, :b 2, :c 3}&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 2 3 4&amp;#93; &amp;#91;&amp;quot;one&amp;quot; &amp;quot;two&amp;quot; &amp;quot;three&amp;quot;&amp;#93;&amp;#41; {1 &amp;quot;one&amp;quot;, 2 &amp;quot;two&amp;quot;, 3 &amp;quot;three&amp;quot;}&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;:foo :bar&amp;#93; &amp;#91;&amp;quot;foo&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;baz&amp;quot;&amp;#93;&amp;#41; {:foo &amp;quot;foo&amp;quot;, :bar &amp;quot;bar&amp;quot;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;제한 : zipmap&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x y&amp;#93;
  &amp;#40;apply array-map &amp;#40;vec &amp;#40;mapcat list x y&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;vec를 빼고도 답이 가능 할 것 같다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x y&amp;#93;
  &amp;#40;apply array-map &amp;#40;mapcat list x y&amp;#41;&amp;#41;&amp;#41;

;; array-map 대신 hash-map
&amp;#40;fn &amp;#91;x y&amp;#93;
  &amp;#40;apply hash-map &amp;#40;mapcat list x y&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;mapcat list는 항상 사용하던 함수지만 어떤 식으로 계산이 되는지 적어둘 필요성은 있다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;mapcat list &amp;#91;:a :b :c&amp;#93; &amp;#91;1 2 3&amp;#93;&amp;#41;
;; &amp;#40;:a 1 :b 2 :c 3&amp;#41;

;; apply를 사용하면 이런 식으로 사용 된다.
&amp;#40;apply hash-map '&amp;#40;:a 1 :b 2 :c 3&amp;#41;&amp;#41;
;; &amp;#40;hash-map :a 1 :b 2 :c 3&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;다른 답들도 있었다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;#&amp;#40;into {} &amp;#40;map vector % %2&amp;#41;&amp;#41;

;; 위 답에 대한 해결되는 과정
&amp;#40;map vector &amp;#91;:a :b :c&amp;#93; &amp;#91;1 2 3&amp;#93;&amp;#41;
;; &amp;#40;&amp;#91;:a 1&amp;#93; &amp;#91;:b 2&amp;#93; &amp;#91;:c 3&amp;#93;&amp;#41;

&amp;#40;into {} '&amp;#40;&amp;#91;:a 1&amp;#93; &amp;#91;:b 2&amp;#93; &amp;#91;:c 3&amp;#93;&amp;#41;&amp;#41;
;; {:a 1, :b 2, :c 3}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
<pubDate>
Wed, 04 Dec 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-12-03-4clojure-60.html
</guid>
<link>
http://dev-happy.com/posts/2019-12-03-4clojure-60.html
</link>
<title>
4clojure - Sequence Reductions (60)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;take 5 &amp;#40;&amp;#95;&amp;#95; + &amp;#40;range&amp;#41;&amp;#41;&amp;#41; &amp;#91;0 1 3 6 10&amp;#93;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; conj &amp;#91;1&amp;#93; &amp;#91;2 3 4&amp;#93;&amp;#41; &amp;#91;&amp;#91;1&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;1 2 3&amp;#93; &amp;#91;1 2 3 4&amp;#93;&amp;#93;&amp;#41;

&amp;#40;= &amp;#40;last &amp;#40;&amp;#95;&amp;#95; &amp;#42; 2 &amp;#91;3 4 5&amp;#93;&amp;#41;&amp;#41; &amp;#40;reduce &amp;#42; 2 &amp;#91;3 4 5&amp;#93;&amp;#41; 120&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;제한 : reductions&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn rd 
	&amp;#40;&amp;#91;f x&amp;#93;
		&amp;#40;rd f &amp;#40;first x&amp;#41; &amp;#40;rest x&amp;#41;&amp;#41;&amp;#41;
  
	&amp;#40;&amp;#91;f value col&amp;#93;
		&amp;#40;if &amp;#40;empty? col&amp;#41; &amp;#40;list value&amp;#41;
			&amp;#40;cons value &amp;#40;lazy-seq &amp;#40;rd f &amp;#40;f value &amp;#40;first col&amp;#41;&amp;#41; &amp;#40;rest col&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;우선 reductions의 동작을 봤는데 아래와 같이 동작을 했다&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;reductions + &amp;#91;1 2 3&amp;#93;&amp;#41;
;; &amp;#40;1 3 6&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;결과 값을 보니 아래의 함수를 사용해서 동작하는 값과 같았다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;map #&amp;#40;reduce + %&amp;#41; &amp;#91;&amp;#91;1&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;1 2 3&amp;#93;&amp;#93;&amp;#41;
;; &amp;#40;1 3 6&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;전개를 하는 식으로 풀이를 했는데 뭔가 일일히 계산 하는 방법도 있겠지만 좀 더 수학적으로 생각하는 방법으로 하고 싶다.&lt;/p&gt;&lt;p&gt;53번 문제를 이런 풀이로 풀었던 기억이 있어서 약간의 응용을 해봤다&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;reduce &amp;#40;fn &amp;#91;acc x&amp;#93; &amp;#40;conj acc &amp;#40;conj &amp;#40;vec &amp;#40;last acc&amp;#41;&amp;#41; x&amp;#41;&amp;#41;&amp;#41; &amp;#91;&amp;#93; &amp;#91;1 2 3 4&amp;#93;&amp;#41;
;; &amp;#91;&amp;#91;1&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;1 2 3&amp;#93; &amp;#91;1 2 3 4&amp;#93;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;위 식과 조합으로 계산식을 만들었다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;map #&amp;#40;reduce + %&amp;#41; &amp;#40;reduce &amp;#40;fn &amp;#91;acc x&amp;#93; &amp;#40;conj acc &amp;#40;conj &amp;#40;vec &amp;#40;last acc&amp;#41;&amp;#41; x&amp;#41;&amp;#41;&amp;#41; &amp;#91;&amp;#93; &amp;#91;1 2 3 4&amp;#93;&amp;#41;&amp;#41;
;; &amp;#40;1 3 6 10&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;익명함수로 만들었다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;f &amp;amp; args&amp;#93;
  &amp;#40;map #&amp;#40;reduce f %&amp;#41; &amp;#40;reduce &amp;#40;fn &amp;#91;acc x&amp;#93; &amp;#40;conj acc &amp;#40;conj &amp;#40;vec &amp;#40;last acc&amp;#41;&amp;#41; x&amp;#41;&amp;#41;&amp;#41; &amp;#91;&amp;#93; args&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;역시나 가변인자의 문제점이 있으므로 apply를 추가 했다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;f &amp;amp; args&amp;#93;
  &amp;#40;map #&amp;#40;reduce f %&amp;#41; &amp;#40;apply reduce &amp;#40;fn &amp;#91;acc x&amp;#93; &amp;#40;conj acc &amp;#40;conj &amp;#40;vec &amp;#40;last acc&amp;#41;&amp;#41; x&amp;#41;&amp;#41;&amp;#41; args&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;실행을 해보니 오류가 나서 reduce를 다시 확인 해봤다&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;reduce &amp;#40;fn &amp;#91;acc x&amp;#93; &amp;#40;conj acc &amp;#40;conj &amp;#40;vec &amp;#40;last acc&amp;#41;&amp;#41; x&amp;#41;&amp;#41;&amp;#41; &amp;#91;1 2 3 4&amp;#93;&amp;#41;
;; Execution error &amp;#40;IllegalArgumentException&amp;#41; at user/eval211$fn &amp;#40;REPL:1&amp;#41;. Don't know how to create ISeq from: java.lang.Long
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;초기 값이 []이 아니기 때문에 last가 성립이 되지 않아 오류가 나오는 것이다.&lt;/p&gt;&lt;p&gt;long을 seq로 변환을 할수가 없다고 한다..그래서 apply도 같은 오류가 나왔던 것 같다. 결과 적으로는 아래의 apply 같은 방식으로 동작을 해야한다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;apply reduce &amp;#40;fn &amp;#91;acc x&amp;#93; &amp;#40;conj acc &amp;#40;conj &amp;#40;vec &amp;#40;last acc&amp;#41;&amp;#41; x&amp;#41;&amp;#41;&amp;#41; '&amp;#40;&amp;#91;&amp;#93; &amp;#91;1 2 3 4&amp;#93;&amp;#41;&amp;#41;
;; &amp;#91;&amp;#91;1&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;1 2 3&amp;#93; &amp;#91;1 2 3 4&amp;#93;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;[]가 없이 해야 위 테스트를 전부 통과를 하는데 그럴려면 if로 확인하고 해야한다. seq?로 확인을 했으나 위 조건에 충족을 하지 않는다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;seq? nil&amp;#41;
;; false
&amp;#40;seq? &amp;#91;1&amp;#93;&amp;#41;
;; false

;; coll?로 해야한다.
&amp;#40;coll? &amp;#91;1&amp;#93;&amp;#41;
;; true
&amp;#40;coll? nil&amp;#41;
;; false
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;coll로 해서 했으나 아래와 같은 애러가 나온다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;reduce &amp;#40;fn &amp;#91;acc x&amp;#93; &amp;#40;if &amp;#40;not &amp;#40;coll? acc&amp;#41;&amp;#41; &amp;#40;conj &amp;#91;&amp;#93; x&amp;#41; &amp;#40;conj acc &amp;#40;conj &amp;#40;vec &amp;#40;last acc&amp;#41;&amp;#41; x&amp;#41;&amp;#41;&amp;#41;&amp;#41; &amp;#91;1 2 3 4&amp;#93;&amp;#41;
;; Execution error at user/eval241$fn &amp;#40;REPL:1&amp;#41;. Unable to convert: class java.lang.Long to Object&amp;#91;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;마지막 결과에 대해서 long 형이기 때문에 []형으로 변경을 할 수가 없다고 한다...이것을 극복하기 위한 방법을 조금 더 고민을 해봐야 겠다.&lt;/p&gt;&lt;p&gt;빈 []로 할 수는 없으므로 값의 일부를 가져와서 하는 방식으로 생각을 해봤다&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;apply reduce &amp;#40;fn &amp;#91;acc x&amp;#93; &amp;#40;conj acc &amp;#40;conj &amp;#40;vec &amp;#40;last acc&amp;#41;&amp;#41; x&amp;#41;&amp;#41;&amp;#41; '&amp;#40;&amp;#91;&amp;#91;1&amp;#93;&amp;#93; &amp;#91;2 3 4&amp;#93;&amp;#41;&amp;#41;
;; &amp;#91;&amp;#91;1&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;1 2 3&amp;#93; &amp;#91;1 2 3 4&amp;#93;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;근데 acc에 대한 이중 괄호가 너무 부자연 스러워 보인다. &lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;'&amp;#40;&amp;#91;1&amp;#93; &amp;#91;2 3 4&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;와 같은 형식으로 하는 방법으로 해야 제대로 모든 계산을 할 수 있을 것 같은데 좀 더 고민이 필요하다.&lt;/p&gt;&lt;p&gt;문제를 다시 뜯어보다보니 생각을 잘 못 하고 있는 것 같았다. 첫번째와 두번째에 대한 형태가 다르다고만 생각을 했었는데 테스트를 하다보니 나중에 계산되어야 하는 값이 따로 있었다는 것을 알게 되었다 아래 테스트를 하면서 알게 된 방법이다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;apply conj &amp;#91;1&amp;#93; &amp;#91;2 3 4&amp;#93;&amp;#41;
;; &amp;#91;1 2 3 4&amp;#93;

&amp;#40;apply &amp;#42; 2 &amp;#91;3 4 5&amp;#93;&amp;#41;
;; 120

&amp;#40;apply + &amp;#91;0 1 2 3 4&amp;#93;&amp;#41;
;; 10

&amp;#40;map #&amp;#40;apply conj &amp;#91;1&amp;#93; %&amp;#41; &amp;#91;&amp;#91;&amp;#93; &amp;#91;2&amp;#93; &amp;#91;2 3&amp;#93; &amp;#91;2 3 4&amp;#93;&amp;#93;&amp;#41;
;; &amp;#40;&amp;#91;1&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;1 2 3&amp;#93; &amp;#91;1 2 3 4&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;대략적으로 문제에 대한 계산식이 나왔다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;map #&amp;#40;apply + %&amp;#41; &amp;#40;apply reduce &amp;#40;fn &amp;#91;acc x&amp;#93; &amp;#40;conj acc &amp;#40;conj &amp;#40;vec &amp;#40;last acc&amp;#41;&amp;#41; x&amp;#41;&amp;#41;&amp;#41; '&amp;#40;&amp;#91;&amp;#91;0&amp;#93;&amp;#93; &amp;#91;1 2 3 4&amp;#93;&amp;#41;&amp;#41;&amp;#41;
;; &amp;#40;0 1 3 6 10&amp;#41;

&amp;#40;map #&amp;#40;apply conj &amp;#91;1&amp;#93; %&amp;#41; &amp;#40;apply reduce &amp;#40;fn &amp;#91;acc x&amp;#93; &amp;#40;conj acc &amp;#40;conj &amp;#40;vec &amp;#40;last acc&amp;#41;&amp;#41; x&amp;#41;&amp;#41;&amp;#41; '&amp;#40;&amp;#91;&amp;#91;20191110 - 정렬,필터 개선안, 헬씨 라벨&amp;#93;&amp;#93; &amp;#91;2 3 4&amp;#93;&amp;#41;&amp;#41;&amp;#41;
;; &amp;#40;&amp;#91;1&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;1 2 3&amp;#93; &amp;#91;1 2 3 4&amp;#93;&amp;#41;

&amp;#40;map #&amp;#40;apply &amp;#42; 2 %&amp;#41; &amp;#40;apply reduce &amp;#40;fn &amp;#91;acc x&amp;#93; &amp;#40;conj acc &amp;#40;conj &amp;#40;vec &amp;#40;last acc&amp;#41;&amp;#41; x&amp;#41;&amp;#41;&amp;#41; '&amp;#40;&amp;#91;&amp;#91;20191110 - 정렬,필터 개선안, 헬씨 라벨&amp;#93;&amp;#93; &amp;#91;3 4 5&amp;#93;&amp;#41;&amp;#41;&amp;#41;

;; &amp;#40;2 6 24 120&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;식은 완성 했는데 잘못된 부분이 있는거 같아서 통과가 되진 않는다 &lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;f x &amp;amp; arg&amp;#93;
	&amp;#40;let &amp;#91;a &amp;#40;if &amp;#40;nil? arg&amp;#41; &amp;#40;first x&amp;#41; &amp;#91;&amp;#93;&amp;#41;
		  b &amp;#40;if &amp;#40;nil? arg&amp;#41; &amp;#40;rest x&amp;#41; arg&amp;#41;
		  c &amp;#40;if &amp;#40;nil? arg&amp;#41; 0 x&amp;#41;&amp;#93;
		&amp;#40;map #&amp;#40;apply f c %&amp;#41; &amp;#40;apply reduce &amp;#40;fn &amp;#91;acc x&amp;#93; &amp;#40;conj acc &amp;#40;conj &amp;#40;vec &amp;#40;last acc&amp;#41;&amp;#41; x&amp;#41;&amp;#41;&amp;#41; &amp;#91;a&amp;#93; b&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;lazy-seq 때문에 테스트를 통과하지 못하고 있다.. lazy-seq를 쓰던 어떻게 하던지 간에 (rest)에서 range에 대한 무한루프가 발생을 한다.&lt;/p&gt;&lt;p&gt;recursive를 이용해서 문제를 풀어야 할 것 같다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn rd 
	&amp;#40;&amp;#91;f x&amp;#93;
		&amp;#40;rd f &amp;#40;first x&amp;#41; &amp;#40;rest x&amp;#41;&amp;#41;&amp;#41;
	&amp;#40;&amp;#91;f value col&amp;#93;
		&amp;#40;if &amp;#40;empty? col&amp;#41; &amp;#40;list value&amp;#41;
			&amp;#40;cons value &amp;#40;lazy-seq &amp;#40;rd f &amp;#40;f value &amp;#40;first col&amp;#41;&amp;#41; &amp;#40;rest col&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
			
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;lazy-seq를 파악하고 공부가 필요하고, 지금까지 과정으로 봤을 때 아무리 생각을 해봐도 문제가 너무 안풀릴 것 같아 인터넷으로 찾아봤고, 약간의 변형을 거쳤다.&lt;/p&gt;&lt;p&gt;우선 기본적으로 lazy-seq를 사용하려면 recursive 적인 함수에서 사용을 해야한다는 것을 알았다. 그렇지 않으면 원하는데로 적용이 되지 않고, 무한루프에 빠진다는 것을 경험을 했기 때문이다. &lt;/p&gt;&lt;p&gt;우선 위 함수와 비슷하게 cons를 [1 2 3 4 ]를 기준으로  recursive 적용을 했을 때는 아래와 같다&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn rd 
	&amp;#40;&amp;#91;x&amp;#93;
		&amp;#40;rd &amp;#40;first x&amp;#41; &amp;#40;rest x&amp;#41;&amp;#41;&amp;#41;
	&amp;#40;&amp;#91;value col&amp;#93;
		&amp;#40;if &amp;#40;empty? col&amp;#41; &amp;#40;list value&amp;#41;
			&amp;#40;cons value &amp;#40;rd &amp;#40;first col&amp;#41; &amp;#40;rest col&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

;; &amp;#91;1 2 3 4&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;생각했던 것과 다른 결과가 나왔다.&lt;br /&gt; (&lt;a href=''&gt;1&lt;/a&gt; &lt;a href=''&gt;1 2 3&lt;/a&gt;) 이렇게 될 줄 알았는데 무언가 계산식이 잘못 되었다는 생각이 들었다.&lt;/p&gt;&lt;p&gt;생각해보니 너무 처음부터 문제를 깊게 생각했던 것 같다. 문제를 인식하는 과정에서 한꺼번에 답을 도출하려고 했던 것이 문제를 푸는데 있어서 걸림돌이 되었던 것 같다.&lt;/p&gt;&lt;p&gt;처음부터 &lt;a href=''&gt;1&lt;/a&gt; &lt;a href=''&gt;1 2 3&lt;/a&gt;) 에서  +를 하는 것이 아니라 계산하는 과정에서 f와 파라미터의 조합으로 되어야 하는데 +를 염두해두고 계산식을 만들어가다보니 이런 문제가 생긴 것 같다. 너무 1번째의 풀이에만 매몰되어 있어서 2번째에 대한 풀이를 1번째와 엮어서 생각을 하다보니 문제 였다는 것을 깨달았다.&lt;/p&gt;
</description>
<pubDate>
Tue, 03 Dec 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-12-02-4clojure-59.html
</guid>
<link>
http://dev-happy.com/posts/2019-12-02-4clojure-59.html
</link>
<title>
4clojure - Juxtaposition (59)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#91;21 6 1&amp;#93; &amp;#40;&amp;#40;&amp;#95;&amp;#95; + max min&amp;#41; 2 3 5 1 6 4&amp;#41;&amp;#41;

&amp;#40;= &amp;#91;&amp;quot;HELLO&amp;quot; 5&amp;#93; &amp;#40;&amp;#40;&amp;#95;&amp;#95; #&amp;#40;.toUpperCase %&amp;#41; count&amp;#41; &amp;quot;hello&amp;quot;&amp;#41;&amp;#41;

&amp;#40;= &amp;#91;2 6 4&amp;#93; &amp;#40;&amp;#40;&amp;#95;&amp;#95; :a :c :b&amp;#41; {:a 2, :b 4, :c 6, :d 8 :e 10}&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;제한 : juxt&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;a b &amp;amp;&amp;#91;c&amp;#93;&amp;#93;
  &amp;#40;fn &amp;#91;&amp;amp; x&amp;#93;
    &amp;#40;if c
      &amp;#40;vector &amp;#40;apply a x&amp;#41; &amp;#40;apply b x&amp;#41; &amp;#40;apply c x&amp;#41;&amp;#41;
      &amp;#40;vector &amp;#40;apply a x&amp;#41; &amp;#40;apply b x&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;juxt의 함수 동작을 구현하는 문제이다. 동작하는 방식은  ((juxt + max min) 2 3 5 1 6 4) 의 결과는 [21 6 1]이 되는데 + 는 21, max = 6, min = 1의 결과가 된다. juxt 함수의 내부가 저렇게 생기지 않았다고 생각이 들지만 문제의 답을 모두 충족하기 때문에 59번 문제 한정해서 충족한다고 생각한다.&lt;/p&gt;
</description>
<pubDate>
Mon, 02 Dec 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-12-01-4clojure-58.html
</guid>
<link>
http://dev-happy.com/posts/2019-12-01-4clojure-58.html
</link>
<title>
4clojure - Function Composition (58)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#91;3 2 1&amp;#93; &amp;#40;&amp;#40;&amp;#95;&amp;#95; rest reverse&amp;#41; &amp;#91;1 2 3 4&amp;#93;&amp;#41;&amp;#41;

&amp;#40;= 5 &amp;#40;&amp;#40;&amp;#95;&amp;#95; &amp;#40;partial + 3&amp;#41; second&amp;#41; &amp;#91;1 2 3 4&amp;#93;&amp;#41;&amp;#41;

&amp;#40;= true &amp;#40;&amp;#40;&amp;#95;&amp;#95; zero? #&amp;#40;mod % 8&amp;#41; +&amp;#41; 3 5 7 9&amp;#41;&amp;#41;

&amp;#40;= &amp;quot;HELLO&amp;quot; &amp;#40;&amp;#40;&amp;#95;&amp;#95; #&amp;#40;.toUpperCase %&amp;#41; #&amp;#40;apply str %&amp;#41; take&amp;#41; 5 &amp;quot;hello world&amp;quot;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;제한 : comp&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;&amp;amp; f&amp;#93;
	&amp;#40;fn &amp;#91;&amp;amp; args&amp;#93;
		&amp;#40;let &amp;#91;rf &amp;#40;reverse f&amp;#41;&amp;#93;
			&amp;#40;reduce &amp;#40;fn &amp;#91;acc x&amp;#93; &amp;#40;x acc&amp;#41;&amp;#41; &amp;#40;apply &amp;#40;first rf&amp;#41; args&amp;#41; &amp;#40;rest rf&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;high-order-function 에 대한 사용 방법이 필요 할 것 같다. 함수를 넘겨주는 함수를 만드는데 시행착오이다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;defn rf &amp;#91;f&amp;#93;
	&amp;#40;f&amp;#41;&amp;#41;

&amp;#40;&amp;#40;rf +&amp;#41; 1 2 3 4&amp;#41;
;; Execution error &amp;#40;ClassCastException&amp;#41; at user/eval230 &amp;#40;REPL:1&amp;#41;. java.lang.Long cannot be cast to clojure.lang.IFn

&amp;#40;defn rf &amp;#91;f&amp;#93;
	&amp;#40;fn &amp;#91;&amp;amp; x&amp;#93;
	&amp;#40;f x&amp;#41;&amp;#41;&amp;#41;

&amp;#40;&amp;#40;rf +&amp;#41; 1 2 3 4&amp;#41;
;; Execution error &amp;#40;ClassCastException&amp;#41; at java.lang.Class/cast &amp;#40;Class.java:3369&amp;#41;. Cannot cast clojure.lang.ArraySeq to java.lang.Number

&amp;#40;&amp;#40;rf +&amp;#41; &amp;#91;1 2 3 4&amp;#93;&amp;#41;
;; Execution error &amp;#40;ClassCastException&amp;#41; at java.lang.Class/cast &amp;#40;Class.java:3369&amp;#41;. Cannot cast clojure.lang.ArraySeq to java.lang.Number

&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;만드는 방법을 확실하게 모르는 상태에서 시도만 계속 하다보니 오류를 남발하고 말았고, &amp;를 이용한 가변 인수가 어떠한 방식으로 안에서 사용 되는지도 모르는 상태에서 하다보니 오류만 발생시카고 말았다 가변 인수는 1 2 3 4  형식으로 사용하는 것이고, 내부에서는 [1 2 3 4] 로 들어온다&lt;/p&gt;&lt;p&gt;연산이 필요한 경우에는 apply를 사용하여 연산을 한다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;defn rf &amp;#91;f&amp;#93;
	&amp;#40;fn &amp;#91;&amp;amp; x&amp;#93;
	&amp;#40;apply f x&amp;#41;&amp;#41;&amp;#41;

&amp;#40;&amp;#40;rf +&amp;#41; 1 2 3 4&amp;#41;
;; 10
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;모든 함수를 처리하는 것을 한번에 만들 수 없을 것 같아서 high-order-function 정의부터 하나하나 테스트 하면서 문제를 풀어보려고 한다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;defn rf &amp;#91;&amp;amp; f&amp;#93;
	&amp;#40;fn &amp;#91;&amp;amp; args&amp;#93;
		&amp;#40;&amp;#40;first f&amp;#41; args&amp;#41;&amp;#41;&amp;#41;

&amp;#40;&amp;#40;rf rest reverse&amp;#41; &amp;#91;1 2 3 4&amp;#93;&amp;#41;
;;&amp;#40;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;rest reverse중 rest를 사용하는 함수를 만들어보고 싶었는데 원하는 결과대로 나오지 않는다.&lt;/p&gt;&lt;p&gt; 직접 rest를 넣어보기로 했다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;defn rf &amp;#91;&amp;amp; f&amp;#93;
	&amp;#40;fn &amp;#91;&amp;amp; args&amp;#93;
		&amp;#40;rest args&amp;#41;&amp;#41;&amp;#41;

&amp;#40;&amp;#40;rf rest reverse&amp;#41; &amp;#91;1 2 3 4&amp;#93;&amp;#41;
;; &amp;#40;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;그래도 원하는 결과가 나오지 않는다.&lt;/p&gt;&lt;p&gt; args에 어떻게 파라미터가 들어가는지 확인을 해봤다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;defn rf &amp;#91;&amp;amp; f&amp;#93;
	&amp;#40;fn &amp;#91;&amp;amp; args&amp;#93;
		&amp;#40;println args&amp;#41;&amp;#41;&amp;#41;

&amp;#40;&amp;#40;rf rest&amp;#41; &amp;#91;1 2 3 4&amp;#93;&amp;#41;
;; &amp;#40;&amp;#91;1 2 3 4&amp;#93;&amp;#41;
;; nil
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;()로 감싸서 들어오는 것을 확인을 하니 apply는 꼭 필요한 것 같다.&lt;/p&gt;&lt;p&gt;apply를 넣고 만들어본 함수이다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;defn rf &amp;#91;&amp;amp; f&amp;#93;
	&amp;#40;fn &amp;#91;&amp;amp; args&amp;#93;
		&amp;#40;apply rest args&amp;#41;&amp;#41;&amp;#41;

&amp;#40;&amp;#40;rf rest&amp;#41; &amp;#91;1 2 3 4&amp;#93;&amp;#41;
;; &amp;#40;2 3 4&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;원하는 결과대로 나온다&lt;/p&gt;&lt;p&gt;이제는 first를 넣고 rest 함수를 선택하도록 만들었다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;defn rf &amp;#91;&amp;amp; f&amp;#93;
	&amp;#40;fn &amp;#91;&amp;amp; args&amp;#93;
		&amp;#40;apply &amp;#40;first f&amp;#41; args&amp;#41;&amp;#41;&amp;#41;

&amp;#40;&amp;#40;rf rest reverse&amp;#41; &amp;#91;1 2 3 4&amp;#93;&amp;#41;
;; &amp;#40;2 3 4&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;reduce로 사용이 가능할 것 같은데 방법은 알아 냈다&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;reduce #&amp;#40;%2 %&amp;#41; &amp;#91;1 2 3 4&amp;#93; &amp;#40;reverse &amp;#91;rest reverse&amp;#93;&amp;#41;&amp;#41;
;; &amp;#40;3 2 1&amp;#41; 
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;근데 문제는 다른 테스트로 있는 , partial, 익명함수에 대한 처리가 문제이고, [rest reverse]는 vector로 해야 결과를 얻을 수 있다 안그러면 nil로 표시가 되는 현상이 있다.&lt;/p&gt;&lt;p&gt;해결 방법이 있는데 4clojure에서는 사용하지 못한다..&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;reduce &amp;#40;fn &amp;#91;acc x&amp;#93; `&amp;#40;&amp;#126;x &amp;#126;acc&amp;#41;&amp;#41; &amp;#91;1 2 3 4&amp;#93; '&amp;#40;rest reverse&amp;#41;&amp;#41;
;; &amp;#40;reverse &amp;#40;rest &amp;#91;1 2 3 4&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;`는 list로 만들기 위한 reader macro를 사용할 수 있는 기호이다. ~는 list 생성시 저장된 값을 사용하게 해준다. 즉 ‘(x acc)로 리스트가 생성되는 것이 아니라 (rest [1 2 3 4])로 리스트가 생성이 된다.&lt;/p&gt;&lt;p&gt;결과 값을 가지고 eval 연산을 수행하면 된다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;eval &amp;#40;reduce &amp;#40;fn &amp;#91;acc x&amp;#93; `&amp;#40;&amp;#126;x &amp;#126;acc&amp;#41;&amp;#41; &amp;#91;1 2 3 4&amp;#93; '&amp;#40;rest reverse&amp;#41;&amp;#41;&amp;#41;
;; &amp;#40;4 3 2&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;reduce에서 함수를 받을 때에는 함수라는 것을 인식을 할 수 있도록 해줘야 한다. ~ 매크로를 넣어줘야 한다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;reduce &amp;#40;fn &amp;#91;acc f&amp;#93; &amp;#40;f acc&amp;#41;&amp;#41; &amp;#91;1 2 3 4&amp;#93; `&amp;#40;&amp;#126;rest &amp;#126;reverse&amp;#41;&amp;#41;
;; &amp;#40;4 3 2&amp;#41;

&amp;#40;reduce &amp;#40;fn &amp;#91;acc f&amp;#93; &amp;#40;f acc&amp;#41;&amp;#41; &amp;#91;1 2 3 4&amp;#93; &amp;#40;reverse `&amp;#40;&amp;#126;rest &amp;#126;reverse&amp;#41;&amp;#41;&amp;#41;
;; &amp;#40;3 2 1&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;그렇다면 인자로 받은 함수를 어떻게 함수로 인식을 해줘야 할까?&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;defn rf &amp;#91;&amp;amp; f&amp;#93;
&amp;#40;fn &amp;#91;&amp;amp; args&amp;#93;
&amp;#40;reduce &amp;#40;fn &amp;#91;acc f&amp;#93; &amp;#40;f &amp;#40;println f&amp;#41;&amp;#41;&amp;#41; args &amp;#40;reverse `&amp;#40;&amp;#126;@f&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;&amp;#40;rf rest reverse&amp;#41; &amp;#91;1 2 3 4&amp;#93;&amp;#41;
;; #object&amp;#91;clojure.core$reverse 0x2db2dd9d clojure.core$reverse@2db2dd9d&amp;#93;
;; #object&amp;#91;clojure.core$rest&amp;#95;&amp;#95;5388 0x35293c05  clojure.core$rest&amp;#95;&amp;#95;5388@35293c05&amp;#93;
;; &amp;#40;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;원하는 답은 아니지만 f로 들어오는 함수의 리스트를 풀어서 함수임을 인식하는 ~@ 매크로를 사용하면 된다.&lt;/p&gt;&lt;p&gt;args에 대해서 아직 풀지못한 숙제가 있는데 그것은 [1 2 3 4]로 들어오는 args는 ([1 2 3 4])로 되어 버린다. 이것을 [1 2 3 4]로 만들어줘야 정상적인 답을 얻을 수 있다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;defn rf &amp;#91;&amp;amp; f&amp;#93;
&amp;#40;fn &amp;#91;&amp;amp; args&amp;#93;
&amp;#40;reduce &amp;#40;fn &amp;#91;acc f&amp;#93; &amp;#40;f &amp;#40;println args&amp;#41;&amp;#41;&amp;#41; args &amp;#40;reverse `&amp;#40;&amp;#126;@f&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;&amp;#40;rf rest reverse&amp;#41; &amp;#91;1 2 3 4&amp;#93;&amp;#41;
;; &amp;#40;&amp;#91;1 2 3 4&amp;#93;&amp;#41;
;; &amp;#40;&amp;#91;1 2 3 4&amp;#93;&amp;#41;
;; &amp;#40;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;&amp;amp; f&amp;#93;
	&amp;#40;fn &amp;#91;&amp;amp; args&amp;#93;
		&amp;#40;let &amp;#91;rf &amp;#40;reverse f&amp;#41;&amp;#93;
			&amp;#40;reduce &amp;#40;fn &amp;#91;acc x&amp;#93; &amp;#40;x acc&amp;#41;&amp;#41; &amp;#40;apply &amp;#40;first rf&amp;#41; args&amp;#41; &amp;#40;rest rf&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;문제의 답을 조금 참조를 해서 너무나도 쉽게 문제를 풀 수 있었다. 거의 다 오긴 했었는데 apply의 활용을 헤매다 보니 좀 많이 오래 걸렸다.&lt;/p&gt;&lt;p&gt;apply를 활용해야 ([])를 해결 할 수 있는데 그것을 생각 하지 못했다. 왜 초기화 인수에 apply를 해볼 생각을 못했었는지.. 무엇에 사로잡혀 문제를 헤메고 있었는지 나도 잘 모르겠다..조금 만 더 apply를 생각 했었다면 풀수도 있었을 것 같은데 안될거라고 생각을 했던 것이 다른 방향으로 문제를 풀려고 했던 것 같다, 결론 적으로는 `(~@)를 사용하면서까지 할 필요는 없었다는 것이고, 계산의 결과를 args로 해도 된다는 것을 깨달았다.&lt;/p&gt;
</description>
<pubDate>
Sun, 01 Dec 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-30-4clojure-57.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-30-4clojure-57.html
</link>
<title>
4clojure - Simple Recursion (57)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;&amp;#40;fn foo &amp;#91;x&amp;#93; &amp;#40;when &amp;#40;&amp;gt; x 0&amp;#41; &amp;#40;conj &amp;#40;foo &amp;#40;dec x&amp;#41;&amp;#41; x&amp;#41;&amp;#41;&amp;#41; 5&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;'&amp;#40;5 4 3 2 1&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;recursive 문제이다 풀이를 한다면 아래와 같다&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;conj &amp;#40;conj &amp;#40;conj &amp;#40;conj &amp;#40;conj nil 1&amp;#41; 2&amp;#41; 3&amp;#41; 4&amp;#41; 5&amp;#41;
;; &amp;#40;conj &amp;#40;conj &amp;#40;conj &amp;#40;conj &amp;#40;1&amp;#41; 2&amp;#41; 3&amp;#41; 4&amp;#41; 5&amp;#41;
;; &amp;#40;conj &amp;#40;conj &amp;#40;conj &amp;#40;2 1&amp;#41; 3&amp;#41; 4&amp;#41; 5&amp;#41;
;; &amp;#40;conj &amp;#40;conj &amp;#40;3 2 1&amp;#41; 4&amp;#41; 5&amp;#41;
;; &amp;#40;conj &amp;#40;4 3 2 1&amp;#41; 5&amp;#41;
;; &amp;#40;5 4 3 2 1&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
<pubDate>
Sat, 30 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-29-4clojure-56.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-29-4clojure-56.html
</link>
<title>
4clojure - Find Distinct Items (56)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 2 1 3 1 2 4&amp;#93;&amp;#41; &amp;#91;1 2 3 4&amp;#93;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;:a :a :b :b :c :c&amp;#93;&amp;#41; &amp;#91;:a :b :c&amp;#93;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;&amp;#91;2 4&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;1 3&amp;#93; &amp;#91;1 3&amp;#93;&amp;#41;&amp;#41; '&amp;#40;&amp;#91;2 4&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;1 3&amp;#93;&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#40;range 50&amp;#41;&amp;#41; &amp;#40;range 50&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;coll&amp;#93;
  &amp;#40;reduce &amp;#40;fn &amp;#91;acc num&amp;#93; 
            &amp;#40;if &amp;#40;some true? &amp;#40;map #&amp;#40;= % num&amp;#41; acc&amp;#41;&amp;#41; acc
              &amp;#40;conj acc num&amp;#41;&amp;#41;&amp;#41; &amp;#91;&amp;#93; coll&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;순회하는 방식으로 [] 안에 값이 있으면 누적된 []를, 없으면 []안에 값을 추가하는 방식으로 문제를 해결 했다.&lt;/p&gt;&lt;p&gt;다른 사람이 푼 해결책을 보면&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved 2&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;reduce #&amp;#40;{%2 %} &amp;#40;&amp;#40;set %&amp;#41; %2&amp;#41; &amp;#40;conj % %2&amp;#41;&amp;#41; &amp;#91;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;reduce 연산을 풀이하면 아래와 같다&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;{1 &amp;#91;&amp;#93;} &amp;#40;&amp;#40;set &amp;#91;&amp;#93;&amp;#41; 1&amp;#41; &amp;#40;conj &amp;#91;&amp;#93; 1&amp;#41;&amp;#41;
;; &amp;#91;1&amp;#93;

&amp;#40;{2 &amp;#91;1&amp;#93;} &amp;#40;&amp;#40;set &amp;#91;1&amp;#93;&amp;#41; 2&amp;#41; &amp;#40;conj &amp;#91;1&amp;#93; 2&amp;#41;&amp;#41;
;; &amp;#91;1 2&amp;#93;

&amp;#40;{1 &amp;#91;1 2&amp;#93;} &amp;#40;&amp;#40;set &amp;#91;1 2&amp;#93;&amp;#41; 1&amp;#41; &amp;#40;conj &amp;#91;1 2&amp;#93; 1&amp;#41;&amp;#41;
;; &amp;#91;1 2&amp;#93;

&amp;#40;{3 &amp;#91;1 2&amp;#93;} &amp;#40;&amp;#40;set &amp;#91;1 2&amp;#93;&amp;#41; 3&amp;#41; &amp;#40;conj &amp;#91;1 2&amp;#93; 3&amp;#41;&amp;#41;
;; &amp;#91;1 2 3&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;중복 되는 값은 원래의 acc로 계산된 vector를 리턴하고 없으면 (conj)로 acc에 값을 추가하는 방식으로 계산을 한다. set에 값이 있을때와 없을 때의 연산을 비교해서 본다면 아래와 같다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;;; set 안에 값이 있을 때
&amp;#40;{1 &amp;#91;1 2&amp;#93;} &amp;#40;&amp;#40;set &amp;#91;1 2&amp;#93;&amp;#41; 1&amp;#41; &amp;#40;conj &amp;#91;1 2&amp;#93; 1&amp;#41;&amp;#41;
;; &amp;#40;{1 &amp;#91;1 2&amp;#93;} 1 &amp;#40;conj &amp;#91;1 2&amp;#93; 1&amp;#41;&amp;#41;
;; &amp;#91;1 2&amp;#93;

;; set 안에 값이 없을 때
&amp;#40;{3 &amp;#91;1 2&amp;#93;} &amp;#40;&amp;#40;set &amp;#91;1 2&amp;#93;&amp;#41; 3&amp;#41; &amp;#40;conj &amp;#91;1 2&amp;#93; 3&amp;#41;&amp;#41;
;; &amp;#40;{3 &amp;#91;1 2&amp;#93;} nil &amp;#40;conj &amp;#91;1 2&amp;#93; 3&amp;#41;&amp;#41; 
;; &amp;#40;conj &amp;#91;1 2&amp;#93; 3&amp;#41;
;; &amp;#91;1 2 3&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;nil 값은 hash-map 안에 없으므로  conj 연산으로 값을 추가해 준다.&lt;/p&gt;&lt;p&gt;이런 방식이 실제 프로그래밍 하면서 쓰이지 않을 것 같다는 생각이 들긴 하지만 알아두면 그리고 분석을 할 줄 안다면 많은 도움이 될 것 같다.&lt;/p&gt;
</description>
<pubDate>
Fri, 29 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-28-4clojure-55.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-28-4clojure-55.html
</link>
<title>
4clojure - Count Occurrences (55)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41; {1 4, 2 2, 3 1}&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;:b :a :b :a :b&amp;#93;&amp;#41; {:a 2, :b 3}&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;&amp;#91;1 2&amp;#93; &amp;#91;1 3&amp;#93; &amp;#91;1 3&amp;#93;&amp;#41;&amp;#41; {&amp;#91;1 2&amp;#93; 1, &amp;#91;1 3&amp;#93; 2}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;제한 : frequencies&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x&amp;#93; 
  &amp;#40;-&amp;gt;&amp;gt;
   &amp;#40;partition-by identity &amp;#40;sort x&amp;#41;&amp;#41;
   &amp;#40;map #&amp;#40;list &amp;#40;first %&amp;#41; &amp;#40;count %&amp;#41;&amp;#41;&amp;#41;
   &amp;#40;apply concat&amp;#41;
   &amp;#40;apply hash-map&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;처음에는 group-by로 하면 될 것 이라고 생각을 했다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;group-by count &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41;
;;Execution error &amp;#40;UnsupportedOperationException&amp;#41; at user/eval296 &amp;#40;REPL:1&amp;#41;. 
;;count not supported on this type: Long
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;근데 group-by는 string 값만 된다는 것을 알게 되었고, 다른 방법을 고민 했다.&lt;/p&gt;&lt;p&gt;갯수를 알아내기 위해 같은 값을 묶는 것이 필요하다고 생각하여  partition-by를 생각 했다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;partition-by identity &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41;
;; &amp;#40;&amp;#40;1 1&amp;#41; &amp;#40;2&amp;#41; &amp;#40;3&amp;#41; &amp;#40;2&amp;#41; &amp;#40;1 1&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;근데 얖에서부터 같은 값만 찾다보니 뒤에 같은 값이 있을 경우에는 같이 묶어주지 못하는 현상이 있어서 sort를 적용 했다. key에 대한 sort도 되는지 테스트를 했다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;sort &amp;#91;:b :a :b :a :b&amp;#93;&amp;#41;
;; &amp;#40;:a :a :b :b :b&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;다행히 sort가 되어서 적용을 했다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;partition-by identity &amp;#40;sort &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41;&amp;#41;
;; &amp;#40;&amp;#40;1 1 1 1&amp;#41; &amp;#40;2 2&amp;#41; &amp;#40;3&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;이제 map으로 count를 적용하면 될거 같다. 슬슬 길어지므로 -&gt;&gt;를 사용 했다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;-&amp;gt;&amp;gt;
	&amp;#40;partition-by identity &amp;#40;sort &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41;&amp;#41;
	&amp;#40;map #&amp;#40;count %&amp;#41;&amp;#41;&amp;#41;
;; &amp;#40;4 2 1&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;어떤 항목의 갯수가 같이 표시되지 않으므로 표시되도록 추가 했다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;;; 오류 상황1
&amp;#40;-&amp;gt;&amp;gt;
	&amp;#40;partition-by identity &amp;#40;sort &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41;&amp;#41;
	&amp;#40;map #&amp;#40;% &amp;#40;count %&amp;#41;&amp;#41;&amp;#41;&amp;#41;
;; Error printing return value &amp;#40;ClassCastException&amp;#41; at user/eval318$fn &amp;#40;NO&amp;#95;SOURCE&amp;#95;FILE:1&amp;#41;.
clojure.lang.Cons cannot be cast to clojure.lang.IFn

;; 오류 상황2
&amp;#40;-&amp;gt;&amp;gt;
	&amp;#40;partition-by identity &amp;#40;sort &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41;&amp;#41;
	&amp;#40;map #&amp;#40;&amp;#91;% &amp;#40;count %&amp;#41;&amp;#93;&amp;#41;&amp;#41;
;; Error printing return value &amp;#40;ArityException&amp;#41; at clojure.lang.AFn/throwArity &amp;#40;AFn.java:429&amp;#41;.
Wrong number of args &amp;#40;0&amp;#41; passed to: clojure.lang.PersistentVector
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;마음처럼 잘 안된다...함수를 넣어야 하는데 엉뚱한 값을 넣고 있었다..&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;-&amp;gt;&amp;gt;
	&amp;#40;partition-by identity &amp;#40;sort &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41;&amp;#41;
	&amp;#40;map #&amp;#40;list % &amp;#40;count %&amp;#41;&amp;#41;&amp;#41;
;; &amp;#40;&amp;#40;&amp;#40;1 1 1 1&amp;#41; 4&amp;#41; &amp;#40;&amp;#40;2 2&amp;#41; 2&amp;#41; &amp;#40;&amp;#40;3&amp;#41; 1&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;전체 값이 필요한 것은 아니므로 first로 1개만 표시되도록 했다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;-&amp;gt;&amp;gt;
	&amp;#40;partition-by identity &amp;#40;sort &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41;&amp;#41;
	&amp;#40;map #&amp;#40;list &amp;#40;first %&amp;#41; &amp;#40;count %&amp;#41;&amp;#41;&amp;#41;
;; &amp;#40;&amp;#40;1 4&amp;#41; &amp;#40;2 2&amp;#41; &amp;#40;3 1&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;이걸 이제 hash-map으로 바꾸면 끝이다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;-&amp;gt;&amp;gt;
	&amp;#40;partition-by identity &amp;#40;sort &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41;&amp;#41;
	&amp;#40;map #&amp;#40;list &amp;#40;first %&amp;#41; &amp;#40;count %&amp;#41;&amp;#41;&amp;#41;
	&amp;#40;into {}&amp;#41;&amp;#41;

;; Execution error &amp;#40;ClassCastException&amp;#41; at user/eval342 &amp;#40;REPL:1&amp;#41;. java.lang.Long cannot be cast to java.util.Map$Entry

&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;hash-map 형식이 아니라서 안된단다....&lt;/p&gt;&lt;p&gt;그러면 전체 값을 하나로 합친 후에 하면 되지 않을까? 일단 합쳐보기로 했다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;-&amp;gt;&amp;gt;
	&amp;#40;partition-by identity &amp;#40;sort &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41;&amp;#41;
	&amp;#40;map #&amp;#40;list &amp;#40;first %&amp;#41; &amp;#40;count %&amp;#41;&amp;#41;&amp;#41;
	&amp;#40;apply concat&amp;#41;&amp;#41;
;; &amp;#40;1 4 2 2 3 1&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;근데 일단 다른 문항에 잇는 값들이 제대로 합쳐지는지 궁금해서 테스트 해봤다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;-&amp;gt;&amp;gt;
	&amp;#40;partition-by identity &amp;#40;sort '&amp;#40;&amp;#91;1 2&amp;#93;, &amp;#91;1 3&amp;#93;, &amp;#91;1 3&amp;#93;&amp;#41;&amp;#41;&amp;#41;
	&amp;#40;map #&amp;#40;list &amp;#40;first %&amp;#41; &amp;#40;count %&amp;#41;&amp;#41;&amp;#41;
	&amp;#40;apply concat&amp;#41;&amp;#41;
;; &amp;#40;&amp;#91;1 2&amp;#93; 1 &amp;#91;1 3&amp;#93; 2&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;원하는데로 합쳐지는 것 같다.&lt;/p&gt;&lt;p&gt;이제 hash-map을 적용 해보자 &lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;-&amp;gt;&amp;gt;
	&amp;#40;partition-by identity &amp;#40;sort &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41;&amp;#41;
	&amp;#40;map #&amp;#40;list &amp;#40;first %&amp;#41; &amp;#40;count %&amp;#41;&amp;#41;&amp;#41;
	&amp;#40;apply hash-map concat&amp;#41;&amp;#41;

;; Execution error &amp;#40;IllegalArgumentException&amp;#41; at user/eval366 &amp;#40;REPL:1&amp;#41;. No value supplied for key: &amp;#40;&amp;#91;1 3&amp;#93; 2&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;key가 필요하다고 안된단다...&lt;/p&gt;&lt;p&gt;그럼 이렇게는 어떨까?&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;-&amp;gt;&amp;gt;
	&amp;#40;partition-by identity &amp;#40;sort &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41;&amp;#41;
	&amp;#40;map #&amp;#40;list &amp;#40;first %&amp;#41; &amp;#40;count %&amp;#41;&amp;#41;&amp;#41;
	&amp;#40;apply into hash-map concat&amp;#41;&amp;#41;
;; Execution error &amp;#40;ArityException&amp;#41; at user/eval372 &amp;#40;REPL:1&amp;#41;.
Wrong number of args &amp;#40;4&amp;#41; passed to: clojure.core/into
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;into 의 파리미터 갯수가 아니라고 하니 이 방법도 아닌것 같다.&lt;/p&gt;&lt;p&gt;하나로 합친 값에 너무 이상한 함수의 나열이라고 생각이 들어 다시 재정돈 하였다 우선 값을 합친 부분에서 다시 시작해보기로 했다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;-&amp;gt;&amp;gt;
	&amp;#40;partition-by identity &amp;#40;sort &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41;&amp;#41;
	&amp;#40;map #&amp;#40;list &amp;#40;first %&amp;#41; &amp;#40;count %&amp;#41;&amp;#41;&amp;#41;
	&amp;#40;apply concat&amp;#41;&amp;#41;
;; &amp;#40;1 4 2 2 3 1&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;hash-map의 사용법을 다시 테스트 해봤다. 위의 값을 가지고 다시 테스트 했다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;;; 오류 상황
&amp;#40;hash-map '&amp;#40;1 4 2 2 3 1&amp;#41;&amp;#41;
;; Execution error &amp;#40;IllegalArgumentException&amp;#41; at user/eval418 &amp;#40;REPL:1&amp;#41;. No value supplied for key: &amp;#40;1 4 2 2 3 1&amp;#41;

&amp;#40;hash-map 1 4 2 2 3 1&amp;#41;
;; {1 4, 3 1, 2 2}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;사용법을 확실하게 알고 있지 않아서 발생한 오류라고 생각 한다...이제 apply로 합치면 문제가 해결 된다.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;-&amp;gt;&amp;gt;
	&amp;#40;partition-by identity &amp;#40;sort &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41;&amp;#41;
	&amp;#40;map #&amp;#40;list &amp;#40;first %&amp;#41; &amp;#40;count %&amp;#41;&amp;#41;&amp;#41;
	&amp;#40;apply concat&amp;#41;
	&amp;#40;apply hash-map&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Solved 2&lt;/strong&gt; 문제를 풀고 나서 다른 방식도 있다는 것을 알게되어 분석 하고 싶어졌다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;comp &amp;#40;partial apply zipmap&amp;#41; 
      &amp;#40;juxt keys &amp;#40;comp &amp;#40;partial map count&amp;#41; vals&amp;#41;&amp;#41; 
      &amp;#40;partial group-by identity&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;위에 답에 대한 과정을 하나하나 뜯어 봤다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;&amp;#40;partial group-by identity&amp;#41; &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41;
;; {1 &amp;#91;1 1 1 1&amp;#93;, 2 &amp;#91;2 2&amp;#93;, 3 &amp;#91;3&amp;#93;}

&amp;#40;group-by identity &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41;
;; {1 &amp;#91;1 1 1 1&amp;#93;, 2 &amp;#91;2 2&amp;#93;, 3 &amp;#91;3&amp;#93;}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;group-by가 string에 대한 것인줄 알았는데 아니라는 것을 알게 되었다... identity가 이럴때도 사용 가능하다는 것을 다시한번 알게 되었다. 근데 왜 partial을 사용한건지는 잘 모르겠다. group-by만 해도 될거 같은데..&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;&amp;#40;comp &amp;#40;partial apply zipmap&amp;#41;
      &amp;#40;juxt keys &amp;#40;comp &amp;#40;partial map count&amp;#41; vals&amp;#41;&amp;#41;
      &amp;#40;group-by identity&amp;#41;&amp;#41; &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41;
;; Execution error &amp;#40;ArityException&amp;#41; at user/eval474 &amp;#40;REPL:3&amp;#41;.
Wrong number of args &amp;#40;1&amp;#41; passed to: clojure.core/group-by
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;안된다...partial이 있으면 무언가 준비된 상태로 둔다는 생각이 들었다. &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;apply #&amp;#40;conj &amp;#91;0 1&amp;#93; %&amp;#41; &amp;#91;2 3 4 5&amp;#93;&amp;#41;
;; Execution error &amp;#40;ArityException&amp;#41; at user/eval482 &amp;#40;REPL:1&amp;#41;.
Wrong number of args &amp;#40;4&amp;#41; passed to: user/eval482/fn--483

&amp;#40;apply #&amp;#40;conj &amp;#91;0 1&amp;#93; %&amp;amp;&amp;#41; &amp;#91;2 3 4 5&amp;#93;&amp;#41;
;; &amp;#91;0 1 &amp;#40;2 3 4 5&amp;#41;&amp;#93;

&amp;#40;apply &amp;#40;partial conj &amp;#91;0 1&amp;#93;&amp;#41; &amp;#91;2 3 4 5&amp;#93;&amp;#41;
;; &amp;#91;0 1 2 3 4 5&amp;#93; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;partial의 예제를 보니 실행을 할때 그때 조합을 만들어서 실행시키는 역할이 partial인 것 같다.&lt;/p&gt;&lt;p&gt;간단한 예제를 comp와 엮어서 만들어 봤을 때 아무래도 comp의 영향으로 partial이 없으면 안되는 것 같다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;&amp;#40;comp &amp;#40;apply +&amp;#41;&amp;#41; &amp;#91;1 2 3 4 5 6&amp;#93;&amp;#41;
;; Execution error &amp;#40;ArityException&amp;#41; at user/eval492 &amp;#40;REPL:1&amp;#41;.
Wrong number of args &amp;#40;1&amp;#41; passed to: clojure.core/apply

&amp;#40;&amp;#40;comp &amp;#40;partial apply +&amp;#41;&amp;#41; &amp;#91;1 2 3 4 5 6&amp;#93;&amp;#41;
;; 21
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;juxt는 원하는 항목을 vector로 엮어주는 함수이다. 즉, (list (first x) (count x))를 juxt로 얶어서 만들었다고 생각하면 될 것 같다.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;&amp;#40;comp &amp;#40;juxt keys &amp;#40;comp &amp;#40;partial map count&amp;#41; vals&amp;#41;&amp;#41; 
      &amp;#40;partial group-by identity&amp;#41; &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41; 
;; {1 &amp;#91;1 1 1 1&amp;#93;, 2 &amp;#91;2 2&amp;#93;, 3 &amp;#91;3&amp;#93;} -&amp;gt; 1번 항목
;; keys : &amp;#40;1 2 3&amp;#41;, vals : &amp;#91;&amp;#91;1 1 1 1&amp;#93; &amp;#91;2 2&amp;#93; &amp;#91;3&amp;#93;&amp;#93;
;; &amp;#91;&amp;#40;1 2 3&amp;#41; &amp;#40;4 2 1&amp;#41;&amp;#93; -&amp;gt; 2번 항목
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;결과로 나오는  (1, 2, 3)은 1번 항목의 hash-map keys로 엮은 값이고, (4 2 1)은 1번 항목의 hash-map vals로 가져온 (comp (partial map count)  vals)로 계산된 값의 list로 생각하면 된다. 그래서 2번 항목이 계산 결과 값으로 나온다.&lt;/p&gt;&lt;p&gt;zipmap은 [(1 2 3) (4 2 1)]의 값을 합쳐서 하나의 hash-map으로 만들어준다. apply 없이 예제를 만든다면 아래와 같다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;zipmap '&amp;#40;1 2 3&amp;#41; '&amp;#40;4 2 1&amp;#41;&amp;#41;
;; {1 4, 2 2, 3 1}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;apply로 엮으면 아래와 같은 형식이 된다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;apply zipmap &amp;#91;'&amp;#40;1 2 3&amp;#41; '&amp;#40;4 2 1&amp;#41;&amp;#93;&amp;#41;
;; {1 4, 2 2, 3 1}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;comp와  엮이므로 partial이 있어야 계산이 완료가 된다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved 3&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;reduce #&amp;#40;assoc % %2 &amp;#40;+ 1 &amp;#40;% %2 0&amp;#41;&amp;#41;&amp;#41; {}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;이건 위의 방법보다 좀 더 간단한 문제이다.&lt;/p&gt;&lt;p&gt;우선 안쪽부터 분석을 해보면&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;{} 1 0&amp;#41;
;; 0
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;hash-map안에 1이라는 값이 있으면 그 값을 반환하고 없으면 0을 반환한다는 얘기이다. 현재 상황에서는 {}안에 아무런 값이 없으므로 0이 된다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;+ 1 0&amp;#41;
;; 1
&amp;#40;assoc {} 1 1&amp;#41;
;; {1 1}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;그 값이 위와 같은 과정을 거치면 {1 1}이 된다.&lt;/p&gt;&lt;p&gt;다음 반복시에는 아래와 같은 과정을 거친다&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;{1 1} 1 0&amp;#41;
;; 1
&amp;#40;+ 1 1&amp;#41;
;; 2
&amp;#40;assoc {1 1} 1 2&amp;#41;
;; {1 2}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;위 과정은 {1 1} -&gt; {1 2}로 바뀌는 과정을 보여주고 있다, reduce 연산을 마지막까지 거치면 정답은 같아진다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved 4&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;#&amp;#40;apply merge-with + &amp;#40;map &amp;#40;fn &amp;#91;a&amp;#93; {a 1}&amp;#41; %&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;apply에 대한 영향을 주는 함수는 (merge-with +) 에 대해서 영향을 주는 것이지 map에서 부터 영향을 주는 것은 아니다 그러므로 아래와 같은 동작이 되는 것은 아니다&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;map &amp;#40;fn &amp;#91;a&amp;#93; {a 1}&amp;#41; 1 1 2 3 2 1 1&amp;#41;
;; Error printing return value &amp;#40;IllegalArgumentException&amp;#41; at clojure.lang.RT/seqFrom &amp;#40;RT.java:557&amp;#41;. Don't know how to create ISeq from: java.lang.Long
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;map 의 연산은 아래와 같은 결과를 준다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;map &amp;#40;fn &amp;#91;a&amp;#93; {a 1}&amp;#41; &amp;#91;1 1 2 3 2 1 1&amp;#93;&amp;#41;
;; &amp;#40;{1 1} {1 1} {2 1} {3 1} {2 1} {1 1} {1 1}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;apply의 영향으로 merge-with +의 연산은 아래와 같은 방식으로 된다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;merge-with + {1 1} {1 1} {2 1} {3 1} {2 1} {1 1} {1 1}&amp;#41;
;; {1 4, 2 2, 3 1}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;보통 merge는 아래와 같은 동작을 하는데 merge-with는 f를 받아서 추가적인 연산을 하게 된다는 것을 알았다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;merge {1 1} {1 1} {2 1} {3 1} {2 1} {1 1} {1 1}&amp;#41;
;; {1 1, 2 1, 3 1} -&amp;gt; 덮어쓰는 동작을 함

&amp;#40;merge-with + {1 1} {1 1} {2 1} {3 1} {2 1} {1 1} {1 1}&amp;#41;
;; {1 4, 2 2, 3 1} -&amp;gt; + 함수의 영향으로 value에 + 를 한다.
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;merge-with에 익명함수를 만들려면 가변 인자를 받아야 한다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;merge-with #&amp;#40;list %&amp;amp;&amp;#41; {1 1} {1 1} {2 1} {3 1} {2 1} {1 1} {1 1}&amp;#41;
;; {1 &amp;#40;&amp;#40;&amp;#40;&amp;#40;&amp;#40;&amp;#40;1 1&amp;#41;&amp;#41; 1&amp;#41;&amp;#41; 1&amp;#41;&amp;#41;, 2 &amp;#40;&amp;#40;1 1&amp;#41;&amp;#41;, 3 1}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
<pubDate>
Thu, 28 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-27-4clojure-54.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-27-4clojure-54.html
</link>
<title>
4clojure - Partition a Sequence (54)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 3 &amp;#40;range 9&amp;#41;&amp;#41; '&amp;#40;&amp;#40;0 1 2&amp;#41; &amp;#40;3 4 5&amp;#41; &amp;#40;6 7 8&amp;#41;&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 2 &amp;#40;range 8&amp;#41;&amp;#41; '&amp;#40;&amp;#40;0 1&amp;#41; &amp;#40;2 3&amp;#41; &amp;#40;4 5&amp;#41; &amp;#40;6 7&amp;#41;&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 3 &amp;#40;range 8&amp;#41;&amp;#41; '&amp;#40;&amp;#40;0 1 2&amp;#41; &amp;#40;3 4 5&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;제한 : partition, partition-all&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x coll&amp;#93;
  &amp;#40;loop &amp;#91;result &amp;#91;&amp;#93; coll2 coll&amp;#93;
    &amp;#40;if &amp;#40;or &amp;#40;empty? coll2&amp;#41; &amp;#40;&amp;gt; x &amp;#40;count coll2&amp;#41;&amp;#41;&amp;#41; result
        &amp;#40;recur &amp;#40;conj result &amp;#40;take x coll2&amp;#41;&amp;#41; &amp;#40;drop x coll2&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;take, drop을 이용하여 파티션을 나누는 문제 이다. 좀 복잡해 보이기는 하지만 원리는 비슷하다고 생각한다. 좀 더 짧게 할 수 있는 방법이 있을까? 해서 다른 사람이 풀어논 문제를 봤지만 비슷하게 다들 해결을 해서 뭔가 획기적인 그런 것은 없었다.&lt;/p&gt;
</description>
<pubDate>
Wed, 27 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-26-4clojure-53.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-26-4clojure-53.html
</link>
<title>
4clojure - Longest Increasing Sub-Seq (53)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 0 1 2 3 0 4 5&amp;#93;&amp;#41; &amp;#91;0 1 2 3&amp;#93;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;5 6 1 3 2 7&amp;#93;&amp;#41; &amp;#91;5 6&amp;#93;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;2 3 3 4 5&amp;#93;&amp;#41; &amp;#91;3 4 5&amp;#93;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;7 6 5 4&amp;#93;&amp;#41; &amp;#91;&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x&amp;#93;
  &amp;#40;let &amp;#91;v &amp;#40;last 
           &amp;#40;sort 
            &amp;#40;filter 
             &amp;#40;fn &amp;#91;x&amp;#93; &amp;#40;&amp;gt; &amp;#40;count x&amp;#41; 1&amp;#41;&amp;#41; 
             &amp;#40;reduce #&amp;#40;if &amp;#40;= &amp;#40;inc &amp;#40;last &amp;#40;last %&amp;#41;&amp;#41;&amp;#41; %2&amp;#41; &amp;#40;conj % &amp;#40;conj &amp;#40;last %&amp;#41; %2&amp;#41;&amp;#41; &amp;#40;conj % &amp;#91;%2&amp;#93;&amp;#41;&amp;#41; &amp;#91;&amp;#91;&amp;#40;first x&amp;#41;&amp;#93;&amp;#93; &amp;#40;rest x&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;if &amp;#40;nil? v&amp;#41; &amp;#91;&amp;#93; v&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;reduce를 사용해서 하면 될 것 같으면서도 잘 안된다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;reduce #&amp;#40;if &amp;#40;&amp;gt; &amp;#40;last &amp;#40;last %&amp;#41;&amp;#41; %2&amp;#41; &amp;#40;conj &amp;#40;last %&amp;#41; %2&amp;#41;&amp;#41; &amp;#91;&amp;#91;1&amp;#93;&amp;#93; &amp;#91;0 1 2 3 0 4 5&amp;#93;&amp;#41;
;; Execution error &amp;#40;IllegalArgumentException&amp;#41; at user/eval45$fn &amp;#40;REPL:1&amp;#41;. Don't know how to create ISeq from: java.lang.Long
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;위 오류에 대해서는 중간에 사용하는 함수의 구조를 뜯어보면 알 수 있다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;last &amp;#91;&amp;#91;1&amp;#93;&amp;#93;&amp;#41;
;; &amp;#91;1&amp;#93;

&amp;#40;conj &amp;#40;last &amp;#91;&amp;#91;1&amp;#93;&amp;#93;&amp;#41; 0&amp;#41;
;; &amp;#91;1 0&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;위와 같은 식으로 분리가 되기 때문에 반복 될 수록 구조가 맞지 않는 현상이었다.&lt;/p&gt;&lt;p&gt;전체를 남기지 않고 중간에 순서가 있는 값들만 남기면 될 것 같다고 생각을 했다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;reduce #&amp;#40;if &amp;#40;&amp;gt; &amp;#40;last %&amp;#41; %2&amp;#41; &amp;#40;conj % %2&amp;#41; &amp;#40;conj &amp;#91;&amp;#93; %2&amp;#41;&amp;#41; &amp;#91;1&amp;#93; &amp;#91;0 1 2 3 0 4 5&amp;#93;&amp;#41;
;; &amp;#91;5&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;vector의 중첩에 대한 문제를 해결 하기 위해서 아래와 같은 형식으로 수정을 했다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;reduce #&amp;#40;if &amp;#40;&amp;gt; &amp;#40;last &amp;#40;last %&amp;#41;&amp;#41; %2&amp;#41; &amp;#91;&amp;#40;conj &amp;#40;last %&amp;#41; %2&amp;#41;&amp;#93; &amp;#40;conj % &amp;#91;%2&amp;#93;&amp;#41;&amp;#41; &amp;#91;&amp;#91;1&amp;#93;&amp;#93; &amp;#91;0 1 2 3 0 4 5&amp;#93;&amp;#41;
;; &amp;#91;&amp;#91;3 0&amp;#93; &amp;#91;4&amp;#93; &amp;#91;5&amp;#93;&amp;#93;

&amp;#40;reduce #&amp;#40;if &amp;#40;&amp;lt; &amp;#40;last &amp;#40;last %&amp;#41;&amp;#41; %2&amp;#41; &amp;#91;&amp;#40;conj &amp;#40;last %&amp;#41; %2&amp;#41;&amp;#93; &amp;#40;conj % &amp;#91;%2&amp;#93;&amp;#41;&amp;#41; &amp;#91;&amp;#91;1&amp;#93;&amp;#93; &amp;#91;0 1 2 3 0 4 5&amp;#93;&amp;#41;
;; &amp;#91;&amp;#91;0 4 5&amp;#93;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;결과적으로는 순차적인 값의 길이를 찾는 방식으로 해야되는데 생각처럼 잘 안되고 있다.&lt;/p&gt;&lt;p&gt;아래 방식으로 일단 식은 만들어봤다&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;reduce #&amp;#40;if &amp;#40;&amp;lt; &amp;#40;last &amp;#40;last %&amp;#41;&amp;#41; %2&amp;#41; &amp;#40;conj % &amp;#40;conj &amp;#40;last %&amp;#41; %2&amp;#41;&amp;#41; &amp;#40;conj % &amp;#91;%2&amp;#93;&amp;#41;&amp;#41; &amp;#91;&amp;#91;1&amp;#93;&amp;#93; &amp;#91;0 1 2 3 0 4 5&amp;#93;&amp;#41;
;; &amp;#91;&amp;#91;1&amp;#93; &amp;#91;0&amp;#93; &amp;#91;0 1&amp;#93; &amp;#91;0 1 2&amp;#93; &amp;#91;0 1 2 3&amp;#93; &amp;#91;0&amp;#93; &amp;#91;0 4&amp;#93; &amp;#91;0 4 5&amp;#93;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;여기에서 sort를 하고 마지막 값을 가져오면 해결 될 것 같다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;last &amp;#40;sort &amp;#40;reduce #&amp;#40;if &amp;#40;= &amp;#40;inc &amp;#40;last &amp;#40;last %&amp;#41;&amp;#41;&amp;#41; %2&amp;#41; &amp;#40;conj % &amp;#40;conj &amp;#40;last %&amp;#41; %2&amp;#41;&amp;#41; &amp;#40;conj % &amp;#91;%2&amp;#93;&amp;#41;&amp;#41; &amp;#91;&amp;#91;1&amp;#93;&amp;#93; &amp;#91;0 1 2 3 0 4 5&amp;#93;&amp;#41;&amp;#41;&amp;#41;
;; &amp;#91;0 1 2 3&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;테스트는 거의 통과 했는데 마지막 테스트에서 []값에 대한 처리가 되어 있지 않아 실패를 하였다.&lt;/p&gt;&lt;p&gt;그리고 아래는 위 형식을 검증하기 위한 식이다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x&amp;#93;
	&amp;#40;last &amp;#40;sort &amp;#40;reduce #&amp;#40;if &amp;#40;= &amp;#40;inc &amp;#40;last &amp;#40;last %&amp;#41;&amp;#41;&amp;#41; %2&amp;#41; &amp;#40;conj % &amp;#40;conj &amp;#40;last %&amp;#41; %2&amp;#41;&amp;#41; &amp;#40;conj % &amp;#91;%2&amp;#93;&amp;#41;&amp;#41; &amp;#91;&amp;#91;&amp;#40;first x&amp;#41;&amp;#93;&amp;#93; &amp;#40;rest x&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;어차피 순차적인 값의 길이가 제일 긴 값이 필요한 문제이므로 1개 이상일때의 배열만 필터링을 하는 것이 맞는 것 같다&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;filter &amp;#40;fn &amp;#91;x&amp;#93; &amp;#40;&amp;gt; &amp;#40;count x&amp;#41; 1&amp;#41;&amp;#41; &amp;#40;reduce #&amp;#40;if &amp;#40;= &amp;#40;inc &amp;#40;last &amp;#40;last %&amp;#41;&amp;#41;&amp;#41; %2&amp;#41; &amp;#40;conj % &amp;#40;conj &amp;#40;last %&amp;#41; %2&amp;#41;&amp;#41; &amp;#40;conj % &amp;#91;%2&amp;#93;&amp;#41;&amp;#41; &amp;#91;&amp;#91;1&amp;#93;&amp;#93; &amp;#91;0 1 2 3 0 4 5&amp;#93;&amp;#41;&amp;#41;
;; &amp;#40;&amp;#91;0 1&amp;#93; &amp;#91;0 1 2&amp;#93; &amp;#91;0 1 2 3&amp;#93; &amp;#91;4 5&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;그리고 나머지는 last sort로 처리를 하면 될 것 같은데 if 가 필요하므로 let으로 local을 만들어 검증을 하였다.&lt;/p&gt;&lt;p&gt;마지막 테스트 때문에 좀 깔끔하게 끝내진 못한 것 같지만 좀 더 깔끔하게 풀기위한 여지는 남겨두려고 한다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x&amp;#93;
  &amp;#40;let &amp;#91;v &amp;#40;last 
           &amp;#40;sort 
            &amp;#40;filter 
             &amp;#40;fn &amp;#91;x&amp;#93; &amp;#40;&amp;gt; &amp;#40;count x&amp;#41; 1&amp;#41;&amp;#41; 
             &amp;#40;reduce #&amp;#40;if &amp;#40;= &amp;#40;inc &amp;#40;last &amp;#40;last %&amp;#41;&amp;#41;&amp;#41; %2&amp;#41; &amp;#40;conj % &amp;#40;conj &amp;#40;last %&amp;#41; %2&amp;#41;&amp;#41; &amp;#40;conj % &amp;#91;%2&amp;#93;&amp;#41;&amp;#41; &amp;#91;&amp;#91;&amp;#40;first x&amp;#41;&amp;#93;&amp;#93; &amp;#40;rest x&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;if &amp;#40;nil? v&amp;#41; &amp;#91;&amp;#93; v&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
<pubDate>
Tue, 26 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-25-4clojure-52.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-25-4clojure-52.html
</link>
<title>
4clojure - Intro to Destructuring (52)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#91;2 4&amp;#93; &amp;#40;let &amp;#91;&amp;#91;a b c d e&amp;#93; &amp;#91;0 1 2 3 4&amp;#93;&amp;#93; &amp;#95;&amp;#95;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#91;c e&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;인수분해에 대한 문제 이다. 다른 언어의 변수 대입과 동일하다고 생각하면 된다. 그러므로 a=0, b=1,c=2,d=3,e=4가 된다. [2 4]에 대한 동일성을 판단하는 문제 이므로 [c e]가 답이 된다.&lt;/p&gt;
</description>
<pubDate>
Mon, 25 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-24-4clojure-51.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-24-4clojure-51.html
</link>
<title>
4clojure - Advanced Destructuring (51)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#91;1 2 &amp;#91;3 4 5&amp;#93; &amp;#91;1 2 3 4 5&amp;#93;&amp;#93; &amp;#40;let &amp;#91;&amp;#91;a b &amp;amp; c :as d&amp;#93; &amp;#95;&amp;#95;&amp;#93; &amp;#91;a b c d&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#91;1 2 3 4 5&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;parameter 에 대한 인수 분해 문제 이다.[a b &amp; c :as d]의 의미를 알아야 하는데 결과적으로도 &lt;a href=''&gt;1 2 [3 4 5&lt;/a&gt;]가 되어야 한다. 즉 a = 1, b = 2, c = [3 4 5], d = [1 2 3 4 5]일 때 답이 되고, 분해되는 방식도 그 방식과 동일 하다. 사실 :as d는 인수의 전체를 반환하는 것이라 d 값이 무엇인지 를 알 수 있으면 쉽게 풀 수 있다. &lt;/p&gt;
</description>
<pubDate>
Sun, 24 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-23-again-4clojure.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-23-again-4clojure.html
</link>
<title>
4clojure 를 다시 하면서..
</title>
<description>
&lt;p&gt;50번까지 다시 정리를 하고, 풀이들을 보고, 다른 사람의 풀이와 비교를 해보면서 1개의 함수를 가지고 문제를 해결을 한다는 것이 어리석은 판단이라는 것을 깨닫게 되었다. 항상 어떠한 문제들을 해결 하려면 여러 함수의 조합을 사용해서 문제를 푸는 방식이 clojure답게 문제를 푸는 것이 아닌가 하는 생각이 들었다. &lt;/p&gt;&lt;p&gt;어떤 알고리즘을 내가 무식하게 만들어서 푸는 방법도 있겠지만 그걸 생각하기 전에 함수의 조합을 생각하고 이용하는 방법으로 푸는 것도 생각의 확장에 도움이 되리라 생각한다.&lt;/p&gt;
</description>
<pubDate>
Sat, 23 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-22-4clojure-50.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-22-4clojure-50.html
</link>
<title>
4clojure - Split by Type (50)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;set &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 :a 2 :b 3 :c&amp;#93;&amp;#41;&amp;#41; #{&amp;#91;1 2 3&amp;#93; &amp;#91;:a :b :c&amp;#93;}&amp;#41;

&amp;#40;= &amp;#40;set &amp;#40;&amp;#95;&amp;#95; &amp;#91;:a &amp;quot;foo&amp;quot;  &amp;quot;bar&amp;quot; :b&amp;#93;&amp;#41;&amp;#41; #{&amp;#91;:a :b&amp;#93; &amp;#91;&amp;quot;foo&amp;quot; &amp;quot;bar&amp;quot;&amp;#93;}&amp;#41;

&amp;#40;= &amp;#40;set &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;#91;1 2&amp;#93; :a &amp;#91;3 4&amp;#93; 5 6 :b&amp;#93;&amp;#41;&amp;#41; #{&amp;#91;&amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93;&amp;#93; &amp;#91;:a :b&amp;#93; &amp;#91;5 6&amp;#93;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;#&amp;#40;vals &amp;#40;group-by type %&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;같은 조건으로 묶어주는 함수가 group-by라는 것을 문서를 보다가 다시 되뇌었다. 분명히 group-by로 문제를 풀었던 것이 있었는데 생각이 안나는 것을 보면 지속적인 문제 풀이한 것을 봐야하지 않을까?하는 생각이 들었다.&lt;/p&gt;&lt;p&gt;아니면 너무 다른 방식이라서 쉽게 생각을 못했던 것일 수도 있고... 익숙한 방법으로만 생각을 하려고 하다보니 더 쉬운 방법이 생각이 나지 않았다.&lt;/p&gt;&lt;p&gt;우선 group-by를 사용을 했다. 같은 type으로 묶어주면 될 것 같아서 값을 확인 해봤다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;group-by type &amp;#91;1 :a 2 :b 3 :c&amp;#93;&amp;#41;
;; {java.lang.Long &amp;#91;1 2 3&amp;#93;, clojure.lang.Keyword &amp;#91;:a :b :c&amp;#93;}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;map으로 되어 있는 값을 어떻게 다시 꺼내와야 하는지에 대한 고민을 하다보니 concat으로 되지 않을까 해서 시도를 해봤다&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;concat &amp;#40;group-by type &amp;#91;1 :a 2 :b 3 :c&amp;#93;&amp;#41;&amp;#41;
;; &amp;#40;&amp;#91;java.lang.Long &amp;#91;1 2 3&amp;#93;&amp;#93; &amp;#91;clojure.lang.Keyword &amp;#91;:a :b :c&amp;#93;&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;더 깊숙히 들어가 버렸다... 근데 생각 해보니 hash-map이다, key,value로 구성이 되어 있고 keys, values만 가져올수 있는 함수가 있었다는 것이 생각이 났다. 결국에는 테스트를 통과 하기 위해서는 values만 가져오면 된다는 것이 번뜩 생각 났다&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;vals &amp;#40;group-by type &amp;#91;1 :a 2 :b 3 :c&amp;#93;&amp;#41;&amp;#41;
;; &amp;#40;&amp;#91;1 2 3&amp;#93; &amp;#91;:a :b :c&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
<pubDate>
Fri, 22 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-21-4clojure-49.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-21-4clojure-49.html
</link>
<title>
4clojure - Split a sequence (49)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 3 &amp;#91;1 2 3 4 5 6&amp;#93;&amp;#41; &amp;#91;&amp;#91;1 2 3&amp;#93; &amp;#91;4 5 6&amp;#93;&amp;#93;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 1 &amp;#91;:a :b :c :d&amp;#93;&amp;#41; &amp;#91;&amp;#91;:a&amp;#93; &amp;#91;:b :c :d&amp;#93;&amp;#93;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 2 &amp;#91;&amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93; &amp;#91;5 6&amp;#93;&amp;#93;&amp;#41; &amp;#91;&amp;#91;&amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93;&amp;#93; &amp;#91;&amp;#91;5 6&amp;#93;&amp;#93;&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;제한 : split-at&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;n l&amp;#93;
  &amp;#40;list &amp;#40;take n l&amp;#41; &amp;#40;drop n l&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;첫번째 매개변수의 숫자 만큼 첫번째 부분에 두어 2개로 나누는 문제이다. 즉 3일때 [1 2 3 4 5 6]이라면 &lt;a href=''&gt;1 2 3&lt;/a&gt;이 되고 1이라면 &lt;a href=''&gt;1&lt;/a&gt;이 되는 것이다. take로 앞의 갯수 만큼의 원소를 가져오고,  drop으로 뒤 갯수 만큼의 원소를 남긴다. 그것을 list로 조합하면 되는 문제 이다. 다시 보니까 알겠지만 처음에 이 문제를 봤다면 어떠한 과정으로 문제를 접근 해야하는지 고민이 될 것 같긴 하다.&lt;/p&gt;&lt;p&gt;다른 사람들은 juxt를 이용해서 문제를 풀었던데 이것에 대해서도 공부가 필요하다.&lt;/p&gt;
</description>
<pubDate>
Thu, 21 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-20-4clojure-48.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-20-4clojure-48.html
</link>
<title>
4clojure - Intro to some (48)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;some #{2 7 6} &amp;#91;5 6 7 8&amp;#93;&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;some #&amp;#40;when &amp;#40;even? %&amp;#41; %&amp;#41; &amp;#91;5 6 7 8&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;6
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;some 함수 동작 관련 문제 이다. some 함수는 기본적으로  2번째 인자인 collection의 순서를 따른다. 즉, 1번째 문제에서와 같이 1번째 인자에 값이 먼저 있어도 2번째 인자의 순서에 따르기 때문에 6이 되는 것이다. 1번째 인자를 함수로도 판단이 가능하다. pred를predicate라고 하는데 부울 형식으로 값을 돌려주는 형식이라고 한다.&lt;/p&gt;
</description>
<pubDate>
Wed, 20 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-19-4clojure-47.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-19-4clojure-47.html
</link>
<title>
4clojure - Contain Yourself (47)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;contains? #{4 5 6} &amp;#95;&amp;#95;&amp;#41;

&amp;#40;contains? &amp;#91;1 1 1 1 1&amp;#93; &amp;#95;&amp;#95;&amp;#41;

&amp;#40;contains? {4 :a 2 :b} &amp;#95;&amp;#95;&amp;#41;

&amp;#40;not &amp;#40;contains? &amp;#91;1 2 4&amp;#93; &amp;#95;&amp;#95;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;4
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;value값이 있는지 찾는 문제 이다. 하지만 vector에 대해서는 index에 값이 있는지 판단하는 함수로 변한다.  hash-map에 대해서는 key 값의 존재 여부도 판단 가능하다.&lt;/p&gt;
</description>
<pubDate>
Tue, 19 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-18-4clojure-46.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-18-4clojure-46.html
</link>
<title>
4clojure - Flipping out (46)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= 3 &amp;#40;&amp;#40;&amp;#95;&amp;#95; nth&amp;#41; 2 &amp;#91;1 2 3 4 5&amp;#93;&amp;#41;&amp;#41;

&amp;#40;= true &amp;#40;&amp;#40;&amp;#95;&amp;#95; &amp;gt;&amp;#41; 7 8&amp;#41;&amp;#41;

&amp;#40;= 4 &amp;#40;&amp;#40;&amp;#95;&amp;#95; quot&amp;#41; 2 8&amp;#41;&amp;#41;

&amp;#40;= &amp;#91;1 2 3&amp;#93; &amp;#40;&amp;#40;&amp;#95;&amp;#95; take&amp;#41; &amp;#91;1 2 3 4 5&amp;#93; 3&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;f&amp;#93;
  &amp;#40;fn &amp;#91;x y&amp;#93;
    &amp;#40;f y x&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;함수 내부의 함수 정의를 하는 방법으로 문제를 해결 했다. 과정을 설명한다면 처음에 (fn [f])의 실행으로 (fn [x y]가 리턴되고 그 후에 x y값에 해당하는 결과를 (f y x)를 실행하므로써 해결을 한다.즉 이런 모양이다. &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;&amp;#40;&amp;#40;fn &amp;#91;f&amp;#93; &amp;#40;fn &amp;#91;x y&amp;#93; &amp;#40;f y x&amp;#41;&amp;#41;&amp;#41; nth&amp;#41; 2 &amp;#91;1 2 3 4 5&amp;#93;&amp;#41;

&amp;#40;&amp;#40;fn &amp;#91;x y&amp;#93; &amp;#40;nth y x&amp;#41;&amp;#41; 2 &amp;#91;1 2 3 4 5&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;처음과 같은 모양이 되었다가 함수가 실행되고 나서는 두번째와 같은 모양이 된다.&lt;/p&gt;
</description>
<pubDate>
Mon, 18 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-17-4clojure-45.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-17-4clojure-45.html
</link>
<title>
4clojure - Intro to Iterate (45)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;take 5 &amp;#40;iterate #&amp;#40;+ 3 %&amp;#41; 1&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#91;1 4 7 10 13&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;iterate 입문 문제 이다. 단순하게 생각해서 +3을 하면서 5개를 가져오는 문제이다. 근데 iterate를 보면 이제는 계산을 하게 된다. 처음에 1로 시작하고, 그 후 (+ 3 1)로 4가 되고 그 다음에는 (+ 3 4)로 7이 되는 recursive 계산을 하게 된다.&lt;/p&gt;
</description>
<pubDate>
Sun, 17 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-16-4clojure-44.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-16-4clojure-44.html
</link>
<title>
4clojure - Rotate Sequence (44)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 2 &amp;#91;1 2 3 4 5&amp;#93;&amp;#41; '&amp;#40;3 4 5 1 2&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; -2 &amp;#91;1 2 3 4 5&amp;#93;&amp;#41; '&amp;#40;4 5 1 2 3&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 6 &amp;#91;1 2 3 4 5&amp;#93;&amp;#41; '&amp;#40;2 3 4 5 1&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 1 '&amp;#40;:a :b :c&amp;#41;&amp;#41; '&amp;#40;:b :c :a&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; -4 '&amp;#40;:a :b :c&amp;#41;&amp;#41; '&amp;#40;:c :a :b&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;n coll&amp;#93;
	&amp;#40;let &amp;#91;cnt &amp;#40;count coll&amp;#41;
			m &amp;#40;mod n cnt&amp;#41;&amp;#93;
		&amp;#40;apply concat &amp;#40;list &amp;#40;drop m coll&amp;#41; &amp;#40;take m coll&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;partition-by를 사용하면 그룹으로 묶어주는 방법이 있다고 생각 했다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;partition-by #&amp;#40;&amp;gt;= 1 %&amp;#41; &amp;#91;1 2 3 4 5&amp;#93;&amp;#41;
;; &amp;#40;&amp;#40;1&amp;#41; &amp;#40;2 3 4 5&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;위의 결과를 뒤집어서 합치면 되는데 into로 넣는 방법이 생각 났다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;into '&amp;#40;&amp;#41; &amp;#40;partition-by #&amp;#40;&amp;gt;= 1 %&amp;#41; &amp;#91;1 2 3 4 5&amp;#93;&amp;#41;&amp;#41;
;; &amp;#40;&amp;#40;2 3 4 5&amp;#41; &amp;#40;1&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;이 결과를 가지고 이제 합치기만 하면 되므로 concat을 사용 했다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;apply concat &amp;#40;into '&amp;#40;&amp;#41; &amp;#40;partition-by #&amp;#40;&amp;gt;= 1 %&amp;#41; &amp;#91;1 2 3 4 5&amp;#93;&amp;#41;&amp;#41;&amp;#41;
;; &amp;#40;2 3 4 5 1&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;여기까지의 결과만 보고 잘 된 것이라 생각 했는데 ‘(:a :b :c)에 대한 검증을 통과하지 못하므로 다시 해야된다.&lt;/p&gt;&lt;p&gt;index가 필요하다 판단이 들어서 iterate로 index 조합을 만들었다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;interleave &amp;#40;iterate inc 0&amp;#41; &amp;#91;1 2 3 4 5&amp;#93;&amp;#41;
;; &amp;#40;0 1 1 2 2 3 3 4 4 5&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;이렇게 하면 인덱스와 값이 구분이 되지 않으므로 묶는 작업이 필요하다&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;partition 2 &amp;#40;interleave &amp;#40;iterate inc 0&amp;#41; &amp;#91;1 2 3 4 5&amp;#93;&amp;#41;&amp;#41;
;; &amp;#40;&amp;#40;0 1&amp;#41; &amp;#40;1 2&amp;#41; &amp;#40;2 3&amp;#41; &amp;#40;3 4&amp;#41; &amp;#40;4 5&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;만들다보니 보기가 불편해서 -&gt;&gt; 로 보기 편하게 변형 했다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;-&amp;gt;&amp;gt; &amp;#40;interleave &amp;#40;iterate inc 0&amp;#41; &amp;#91;1 2 3 4 5&amp;#93;&amp;#41;
	   &amp;#40;partition 2&amp;#41;&amp;#41;
;; &amp;#40;&amp;#40;0 1&amp;#41; &amp;#40;1 2&amp;#41; &amp;#40;2 3&amp;#41; &amp;#40;3 4&amp;#41; &amp;#40;4 5&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;이제 first 값을 인덱스로 해서 검증을 하면 된다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;-&amp;gt;&amp;gt; &amp;#40;interleave &amp;#40;iterate inc 0&amp;#41; &amp;#91;1 2 3 4 5&amp;#93;&amp;#41;
     &amp;#40;partition 2&amp;#41;
	   &amp;#40;partition-by #&amp;#40;&amp;gt;= 1 &amp;#40;first %&amp;#41;&amp;#41;&amp;#41;&amp;#41;
;; &amp;#40;&amp;#40;&amp;#40;0 1&amp;#41; &amp;#40;1 2&amp;#41;&amp;#41; &amp;#40;&amp;#40;2 3&amp;#41; &amp;#40;3 4&amp;#41; &amp;#40;4 5&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;점점 괄호가 많아지는데 저걸 어떻게 한번에 없애면서 last 값만 가져오는지 고민이 필요하다.&lt;/p&gt;&lt;p&gt;문제를 고민하다가 아무래도 저 안에서 빠져나오지 못할 것 같아서 문제에 대한 search를 했다.&lt;/p&gt;&lt;p&gt;근데 그대로 답을 사용하긴 좀 그래서 mod만 참조를 하고 나머지는 내 생각으로 하기로 했다.&lt;/p&gt;&lt;p&gt;우선 mod는 나머지를 구하는 함수이다. rem과의 차이점은 아래 결과이다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;mod 6 -5&amp;#41;
;; -4 -&amp;gt; &amp;#40;-5 &amp;#42; -2&amp;#41; + -4

&amp;#40;rem 6 -5&amp;#41;
;; 1 -&amp;gt; &amp;#40;-5 &amp;#42; -1&amp;#41; + 1

&amp;#40;mod 6 -10&amp;#41;
;; -4 -&amp;gt; &amp;#40;-10 &amp;#42; -1&amp;#41; -4

&amp;#40;rem 6 -10&amp;#41;
;; 6 -&amp;gt; &amp;#40;-10 &amp;#42; 0&amp;#41; + 6
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;위 문제에 있는 vector의 count와 적용을 한다면&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;mod -2 5&amp;#41;
;; 3 -&amp;gt; &amp;#40;5 &amp;#42; -1&amp;#41; + 3

&amp;#40;rem -2 5&amp;#41;
;; -2 -&amp;gt; &amp;#40;5 &amp;#42; 0&amp;#41; -2

&amp;#40;mod -4 3&amp;#41;
;; 2 -&amp;gt; &amp;#40;3 &amp;#42; -2&amp;#41; +2

&amp;#40;rem -4 3&amp;#41;
;; -1 -&amp;gt; &amp;#40;3 &amp;#42; -1&amp;#41; -1
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;풀이를 만들어 보고 나서도 왜 저렇게 계산을 다르게 해야 되는건지 이해가 잘 가지는 않는다. 계산식을 만들어보면서 어떻게 하면 저 값이 나오는지 생각을 하면서 하다보니 수학 공부를 다시 하게 되는 느낌이었다.&lt;/p&gt;&lt;p&gt;last-take를 할 필요 없이 drop을 사용해서도 문제가 간단하게 풀릴수 있을 것 같아서 사용을 했고, flatten 보다는 apply concat을 사용하여 좀 더 내 생각을 넣도록 문제를 풀었다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;n coll&amp;#93;
	&amp;#40;let &amp;#91;cnt &amp;#40;count coll&amp;#41;
			m &amp;#40;mod n cnt&amp;#41;&amp;#93;
		&amp;#40;apply concat &amp;#40;list &amp;#40;drop m coll&amp;#41; &amp;#40;take m coll&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;근데 생각을 해보니 아래와 같이 좀 더 줄여서도 가능 할 것 같다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;n coll&amp;#93;
	&amp;#40;let &amp;#91;m &amp;#40;mod n &amp;#40;count coll&amp;#41;&amp;#41;&amp;#93;
		&amp;#40;concat &amp;#40;drop m coll&amp;#41; &amp;#40;take m coll&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
<pubDate>
Sat, 16 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-15-4clojure-43.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-15-4clojure-43.html
</link>
<title>
4clojure - Reverse Interleave (43)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 2 3 4 5 6&amp;#93; 2&amp;#41; '&amp;#40;&amp;#40;1 3 5&amp;#41; &amp;#40;2 4 6&amp;#41;&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#40;range 9&amp;#41; 3&amp;#41; '&amp;#40;&amp;#40;0 3 6&amp;#41; &amp;#40;1 4 7&amp;#41; &amp;#40;2 5 8&amp;#41;&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#40;range 10&amp;#41; 5&amp;#41; '&amp;#40;&amp;#40;0 5&amp;#41; &amp;#40;1 6&amp;#41; &amp;#40;2 7&amp;#41; &amp;#40;3 8&amp;#41; &amp;#40;4 9&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;#&amp;#40;apply map list &amp;#40;partition %2 %1&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;지금까지 공부하면서 이것 저것 해본 결과에 대한 도움이 많이 된 것 같다. Medium 문제라서 긴장하고 있었는데 생각보다 간단하게 해결 할 수 있어서 기분은 좋다.&lt;/p&gt;&lt;p&gt;우선 어떻게 나눠서 문제를 풀어야 할까?에 대해서 생각을 많이 하다보니 partition이 떠올랐다. &lt;/p&gt;&lt;p&gt;1번을 예로 들어 partition 을 사용하게 되면 &lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;partition 2 &amp;#91;1 2 3 4 5 6&amp;#93;&amp;#41;
;; &amp;#40;&amp;#40;1 2&amp;#41; &amp;#40;3 4&amp;#41; &amp;#40;5 6&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt; &lt;p&gt;값 하나씩 순회를 하면 될 것이라 생각하고 (map list)를 사용을 했는데&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;map list &amp;#40;partition 2 &amp;#91;1 2 3 4 5 6&amp;#93;&amp;#41;&amp;#41;
;; &amp;#40;&amp;#40;&amp;#40;1 2&amp;#41;&amp;#41; &amp;#40;&amp;#40;3 4&amp;#41;&amp;#41; &amp;#40;&amp;#40;5 6&amp;#41;&amp;#41;&amp;#41; 
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;그래서 다른 방법을 찾아봐야 하는지 생각하다가 그동안 풀었던 문제에서 ((1 2) (3 4) (5 6))을 내부 원소의 1개의 값씩 순회를 하면서 답 과 같은 형태로 만들어주는 방식이 어렴풋이 떠올라서 찾아봤는데 &lt;/p&gt;&lt;p&gt;39번 문제애서 그런 형식이 있었다. &lt;/p&gt;&lt;p&gt;근데 (apply map list)인데 왜 답과 같은 형태가 나오는지는 잘 모르겠다...&lt;/p&gt;&lt;p&gt;(map list)에 다수의 파라미터를 넣으면 결과가 같아진다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;map list ‘&amp;#40;1 2&amp;#41; ‘&amp;#40;3 4&amp;#41; ‘&amp;#40;5 6&amp;#41;&amp;#41;
;; &amp;#40;&amp;#40;1 3 5&amp;#41; &amp;#40;2 4 6&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;apply의 동작이 단순히 collection을 한개 없애주는 함수인줄 알았는데 &lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;apply map list &amp;#40;&amp;#40;1 2&amp;#41; &amp;#40;3 4&amp;#41; &amp;#40;5 6&amp;#41;&amp;#41;&amp;#41;
;;‘&amp;#40;map list ‘&amp;#40;1 2&amp;#41; ‘&amp;#40;3 4&amp;#41; ‘&amp;#40;5 6&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;와 같이  식으로 합쳐주는 함수라는 것을 알았다. &lt;/p&gt;&lt;p&gt;clojure는 공부를 하면 할 수록 심오한 함수의 동작에 다시한번 놀라게 된다.&lt;/p&gt;
</description>
<pubDate>
Fri, 15 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-14-4clojure-42.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-14-4clojure-42.html
</link>
<title>
4clojure - Factorial Fun (42)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 1&amp;#41; 1&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 3&amp;#41; 6&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 5&amp;#41; 120&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 8&amp;#41; 40320&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x&amp;#93;
  &amp;#40;apply &amp;#42; &amp;#40;range 1 &amp;#40;inc x&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;팩토리얼 문제이다. x로 들어오는 값은 포함을 해야하기 때문에 내부에서 계산시 inc로 1 증가 시켜 x의 값을 증가 시켰다. 그에 결과 리스트를 * 하여 값을 도출해 내었다.&lt;/p&gt;
</description>
<pubDate>
Thu, 14 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-13-4clojure-41.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-13-4clojure-41.html
</link>
<title>
4clojure - Drop Every Nth Item (41)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 2 3 4 5 6 7 8&amp;#93; 3&amp;#41; &amp;#91;1 2 4 5 7 8&amp;#93;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;:a :b :c :d :e :f&amp;#93; 2&amp;#41; &amp;#91;:a :c :e&amp;#93;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 2 3 4 5 6&amp;#93; 4&amp;#41; &amp;#91;1 2 3 5 6&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x y&amp;#93;
  &amp;#40;keep-indexed #&amp;#40;if &amp;#40;not= &amp;#40;mod &amp;#40;+ %1 1&amp;#41; y&amp;#41; 0&amp;#41; %2&amp;#41; x&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;나머지 연산을 사용하여 index에 해당하는 배수는 필터링 하고, 나머지 값을 출력하는 문제이다. keep-indexed 함수가 있는데 index, value 형식으로 값을 준다.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;keep-indexed list &amp;#91;:a :b&amp;#93;&amp;#41;
;&amp;#40;&amp;#40;0 :a&amp;#41; &amp;#40;1 :b&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;mod는 나머지 연산 함수 이다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;mod 1 3&amp;#41;
;1

&amp;#40;mod 9 3&amp;#41;
;0
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;solution에는 partition-all이라는 함수가 있는데 묶는 갯수, step을 값으로 받아서 출력하는 방식을 사용 하고 있다.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;partition-all 2 3 &amp;#91;1 2 3 4 5 6 7 8&amp;#93;&amp;#41;
;&amp;#40;&amp;#40;1 2&amp;#41; &amp;#40;4 5&amp;#41; &amp;#40;7 8&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2개씩 값을 묶고, 3step으로 이동하여 나오는 결과 이다.&lt;/p&gt;&lt;p&gt;나뉘어져 있는 결과를 apply + concat 을 사용하여 묶어주면 된다. partition 함수와 비슷한 역할을 하는데 partition은 3개씩 묶고 1개가 남으면 그것을 버리는데  partition-all은 3개씩 묶고 1개가 남으면 그것도 같이 출력을 한다.&lt;/p&gt;
</description>
<pubDate>
Wed, 13 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-12-4clojure-40.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-12-4clojure-40.html
</link>
<title>
4clojure - Interpose a Seq (40)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 0 &amp;#91;1 2 3&amp;#93;&amp;#41; &amp;#91;1 0 2 0 3&amp;#93;&amp;#41;

&amp;#40;= &amp;#40;apply str &amp;#40;&amp;#95;&amp;#95; &amp;quot;, &amp;quot; &amp;#91;&amp;quot;one&amp;quot; &amp;quot;two&amp;quot; &amp;quot;three&amp;quot;&amp;#93;&amp;#41;&amp;#41; &amp;quot;one, two, three&amp;quot;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; :z &amp;#91;:a :b :c :d&amp;#93;&amp;#41; &amp;#91;:a :z :b :z :c :z :d&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;제한 : interpose&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;value y&amp;#93; &amp;#40;butlast &amp;#40;mapcat &amp;#40;fn &amp;#91;x&amp;#93; &amp;#40;list x value&amp;#41;&amp;#41; y&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;butlast는 마지막 값을 버리는 함수이다.&lt;/p&gt;&lt;p&gt;위 풀이 과정이 있지만 좀 더 나은 방법이 없는지 solution을 확인 하였는데 interleave, repeat의 조합을 활용 하는 방법이 있었다.&lt;/p&gt;&lt;p&gt;interleave는 갯수가 같은 seq 2개이상 이 있어야 사용이 가능하지만 repeat을 이용하면 하나의 원소를 반복한 seq로 만들어주게 되어 활용이 가능하다. repeat는 기본적으로 lazy이므로 take를 같이 사용해야 값을 가져올 수 있다.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;take 3 &amp;#40;repeat 0&amp;#41;&amp;#41;
;&amp;#40;0 0 0&amp;#41; 앞의 ;는 주석
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;interleave &amp;#40;repeat 0&amp;#41; &amp;#91;1 2 3&amp;#93;&amp;#41;
;&amp;#40;0 1 0 2 0 3&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;interleave를 보다가 mapcat + repeat 조합으로 같은 결과를 가져올 수 있을 것 같아 시도를 해봤다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;mapcat list &amp;#40;repeat 0&amp;#41; &amp;#91;1 2 3&amp;#93;&amp;#41;
;&amp;#40;0 1 0 2 0 3&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;mapcat이 가능하면 map + concat + apply도 가능하므로 사용을 해봤다. 보기 편하기 위해서 -&gt;&gt;를 사용하였다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;-&amp;gt;&amp;gt; &amp;#40;map list &amp;#40;repeat 0&amp;#41; &amp;#91;1 2 3&amp;#93;&amp;#41;
	   &amp;#40;apply concat&amp;#41;&amp;#41;
;&amp;#40;0 1 0 2 0 3&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;문제의 결과와 같기 위해서는 처음의 0은 없어야 하므로 rest 함수를 사용 하여 처음 값을 버리고 나머지 값을 사용하도록 하면 결과와 같아진다.&lt;/p&gt;
</description>
<pubDate>
Tue, 12 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-11-4clojure-39.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-11-4clojure-39.html
</link>
<title>
4clojure - Interleave Two Seqs (39)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 2 3&amp;#93; &amp;#91;:a :b :c&amp;#93;&amp;#41; '&amp;#40;1 :a 2 :b 3 :c&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 2&amp;#93; &amp;#91;3 4 5 6&amp;#93;&amp;#41; '&amp;#40;1 3 2 4&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 2 3 4&amp;#93; &amp;#91;5&amp;#93;&amp;#41; &amp;#91;1 5&amp;#93;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;30 20&amp;#93; &amp;#91;25 15&amp;#93;&amp;#41; &amp;#91;30 25 20 15&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;제한 : interleave&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved 1&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;mapcat list
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;mapcat이라는 함수가 단순히 map + apply + concat의 합친 함수인줄 알았는데 실제로 해보니 두 함수만 가지고는 해결이 안된다는 것을 깨닫게 되었다. 간단하게 위와같은 형태로 해결이 가능하지만, map + apply + concat으로 해결한 풀이도 추가 한다.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved 2&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;#&amp;#40;-&amp;gt;&amp;gt; &amp;#40;map list %1 %2&amp;#41;
		&amp;#40;apply concat&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;mapcat 함수를 분석 해보니 &lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;apply concat &amp;#40;apply map f colls&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;부분이 있었다 apply map f에 대한 의문점이 생겼었는데 이는 mapcat의 파라미터가 [f &amp; coll]에서 오는 파라미터의 가변성에 착안한 구현이라고 생각 했다.&lt;/p&gt;&lt;p&gt;예를 든다면 (mapcat list [1 2 3] [:a :b :c]) 일때 내부적으로는&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;apply map list &amp;#91;&amp;#91;1 2 3&amp;#93;&amp;#91;:a :b :c&amp;#93;&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;의 형태로 묶여서 들어가므로 apply가 꼭 필요하다. 예전에 알아두었던 개념이었는데 다시 상기를 하면서 정리 한다.&lt;/p&gt;
</description>
<pubDate>
Mon, 11 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-10-4clojure-38.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-10-4clojure-38.html
</link>
<title>
4clojure - Maximum value (38)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 1 8 3 4&amp;#41; 8&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 30 20&amp;#41; 30&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 45 67 11&amp;#41; 67&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved 1&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x &amp;amp; xs&amp;#93;
  &amp;#40;loop &amp;#91;ls xs big x&amp;#93;
    &amp;#40;cond &amp;#40;empty? ls&amp;#41; big
          &amp;#40;&amp;gt; big &amp;#40;first ls&amp;#41;&amp;#41; &amp;#40;recur &amp;#40;rest ls&amp;#41; big&amp;#41;
          :else &amp;#40;recur &amp;#40;rest ls&amp;#41; &amp;#40;first ls&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved 2&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;&amp;amp; x&amp;#93; &amp;#40;last &amp;#40;sort x&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;주어지는 값에서 가장 큰 값을 찾는 문제이다. 예전에 풀었을 때는 너무 길게 풀이를 했었는데 간단한 방법이 있다. sort 후 last 값을 가져오면 가장 큰 값을 가져올 수 있다. 그런데 가변인수를 하는 방법을 몰라서 헤메다가 &amp;를 사용하면 가변 인수라는 것을 알게 되어 또다른 해결책을 만들었다.&lt;/p&gt;
</description>
<pubDate>
Sun, 10 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-09-4clojure-37.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-09-4clojure-37.html
</link>
<title>
4clojure - Regular Expressions (37)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;apply str &amp;#40;re-seq #&amp;quot;&amp;#91;A-Z&amp;#93;+&amp;quot; &amp;quot;bA1B3Ce &amp;quot;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;quot;ABC&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;re-seq 함수는 정규식을 이용하여 문자열을 필터링 한다. re-seq함수로만 했을 때는 (“A”, “B”, “C”)로 결과값이 나오는데, (apply str)이 추가 되어 sequence로 되어있는 문자들을 문자열로 합쳐주는 역할을 한다.&lt;/p&gt;
</description>
<pubDate>
Sat, 09 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-08-4clojure-36.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-08-4clojure-36.html
</link>
<title>
4clojure - Let it Be (36)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= 10 &amp;#40;let &amp;#95;&amp;#95; &amp;#40;+ x y&amp;#41;&amp;#41;&amp;#41;

&amp;#40;= 4 &amp;#40;let &amp;#95;&amp;#95; &amp;#40;+ y z&amp;#41;&amp;#41;&amp;#41;

&amp;#40;= 1 &amp;#40;let &amp;#95;&amp;#95; z&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#91;x 7, y 3, z 1&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;여러개의 값을 local binding을 하여 푸는 문제 이다. 기본적으로  let [] 형태로 여러개의 값을 local binding 가능하고 ,로 binding 별 구분이 가능하다. 변수 선언을 여러개 하는 방법이라고 생각 하면 될 것 같다. 어느 언어에서나 마찬가지 이겠지만 괄호 안에서만 그 값을 사용 가능하다는 것도 동일하다.&lt;/p&gt;
</description>
<pubDate>
Fri, 08 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-07-4clojure-35.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-07-4clojure-35.html
</link>
<title>
4clojure - Local bindings (35)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;let &amp;#91;x 5&amp;#93; &amp;#40;+ 2 x&amp;#41;&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;let &amp;#91;x 3, y 10&amp;#93; &amp;#40;- y x&amp;#41;&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;let &amp;#91;x 21&amp;#93; &amp;#40;let &amp;#91;y 3&amp;#93; &amp;#40;/ x y&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;5
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;let이라는 local binding을 연습하는 문제이다. 다른 언어에서 사용하는 형식인 x = 5 와 같은 형태라고 생각하면 될 것 같다. 한번 선언이 되면 변경이 불가능 하다는 다른 점이 있다.&lt;/p&gt;
</description>
<pubDate>
Thu, 07 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-06-4clojure-34.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-06-4clojure-34.html
</link>
<title>
4clojure - Implement range (34)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 1 4&amp;#41; '&amp;#40;1 2 3&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; -2 2&amp;#41; '&amp;#40;-2 -1 0 1&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 5 8&amp;#41; '&amp;#40;5 6 7&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;제한: range&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x y&amp;#93;
  &amp;#40;loop &amp;#91;lis &amp;#91;&amp;#93; cnt x&amp;#93;
    &amp;#40;if &amp;#40;= cnt y&amp;#41; &amp;#40;seq lis&amp;#41;
      &amp;#40;recur &amp;#40;conj lis cnt&amp;#41; &amp;#40;+ cnt 1&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;recursive를 이용하여 문제를 풀었지만 어딘가 모르게 복잡한 느낌이 많이 들었다. 문제를 풀고 나서 다른 사람이 풀어낸 방식을 보니 take, iterate 함수를 이용하여 문제를 풀이한 것을 봤다. take는 collection의 원소를 원하는 갯수 만큼 가져오는 것이고 iterate는 함수의 계산되는 식을 거쳐서 계속적 인 반복을 하는 함수이다. 두 함수의 조합이 이 문제 풀이에 대한 좋은 조합이라고 생각 한다.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;#&amp;#40;take &amp;#40;- %2 %1&amp;#41; &amp;#40;iterate inc %1&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;
</description>
<pubDate>
Wed, 06 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-05-4clojure-33.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-05-4clojure-33.html
</link>
<title>
4clojure - Replicate a Sequence (33)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 2 3&amp;#93; 2&amp;#41; '&amp;#40;1 1 2 2 3 3&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;:a :b&amp;#93; 4&amp;#41; '&amp;#40;:a :a :a :a :b :b :b :b&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;4 5 6&amp;#93; 1&amp;#41; '&amp;#40;4 5 6&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93;&amp;#93; 2&amp;#41; '&amp;#40;&amp;#91;1 2&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93; &amp;#91;3 4&amp;#93;&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;44 33&amp;#93; 2&amp;#41; &amp;#91;44 44 33 33&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;fn &amp;#91;x y&amp;#93; &amp;#40;mapcat #&amp;#40;repeat y %&amp;#41; x&amp;#41;&amp;#41;

&amp;#40;fn &amp;#91;x y&amp;#93; &amp;#40;mapcat #&amp;#40;take y &amp;#40;iterate identity %&amp;#41;&amp;#41; x&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;collection 안의 값을 파라미터 값 만큼 반복해서 출력을 하는 문제이다. 값의 반복을 반복문을 이용해서 할 수도 있겠지만 같은 값을 원하는 갯수 만큼 생성해주는 repeat를 이용해서 하는 방법도 있다 32번 문제와 같은 mapcat을 이용 했는데 map + apply + concat을 이용해서도 역시 해결 가능 하다.&lt;/p&gt;
</description>
<pubDate>
Tue, 05 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-04-4clojure-32.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-04-4clojure-32.html
</link>
<title>
4clojure - Duplicate a Sequence (32)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 2 3&amp;#93;&amp;#41; '&amp;#40;1 1 2 2 3 3&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;:a :a :b :b&amp;#93;&amp;#41; '&amp;#40;:a :a :a :a :b :b :b :b&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93;&amp;#93;&amp;#41; '&amp;#40;&amp;#91;1 2&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93; &amp;#91;3 4&amp;#93;&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93;&amp;#93;&amp;#41; '&amp;#40;&amp;#91;1 2&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93; &amp;#91;3 4&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;mapcat &amp;#40;fn &amp;#91;x&amp;#93; &amp;#40;list x x&amp;#41;&amp;#41;

mapcat #&amp;#40;repeat 2 %&amp;#41;

mapcat #&amp;#40;take 2 &amp;#40;iterate identity %&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;값을 하나씩 추가로 생성을 하고 collection인 경우 collection을 그대로 복사하는 문제이다. mapcat을 사용하였는데 map  + apply + concat으로 풀어서 해도 해결 가능 하다.&lt;/p&gt;&lt;p&gt;interleave를 사용하여 해결한 방식도 있었는데 같은 collection을 2번 합쳐서 해결하는 방식이 있었다.&lt;/p&gt;&lt;p&gt;interleave의 작동 방식을 테스트하는 예제를 만들어 봤다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;interleave &amp;#91;4 5 6&amp;#93; &amp;#91;1 2 3&amp;#93;&amp;#41;
;; &amp;#40;4 1 5 2 6 3&amp;#41;

&amp;#40;interleave &amp;#91;&amp;#91;4 5 6&amp;#93;&amp;#93; &amp;#91;1 2 3&amp;#93;&amp;#41;
;; &amp;#40;&amp;#91;4 5 6&amp;#93; 1&amp;#41;

&amp;#40;interleave &amp;#91;4&amp;#93; &amp;#91;1 2 3&amp;#93;&amp;#41;
;; &amp;#40;4 1&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
<pubDate>
Mon, 04 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-03-4clojure-31.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-03-4clojure-31.html
</link>
<title>
4clojure - Pack a Sequence (31)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 1 2 1 1 1 3 3&amp;#93;&amp;#41; '&amp;#40;&amp;#40;1 1&amp;#41; &amp;#40;2&amp;#41; &amp;#40;1 1 1&amp;#41; &amp;#40;3 3&amp;#41;&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;:a :a :b :b :c&amp;#93;&amp;#41; '&amp;#40;&amp;#40;:a :a&amp;#41; &amp;#40;:b :b&amp;#41; &amp;#40;:c&amp;#41;&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;#91;1 2&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93;&amp;#93;&amp;#41; '&amp;#40;&amp;#40;&amp;#91;1 2&amp;#93; &amp;#91;1 2&amp;#93;&amp;#41; &amp;#40;&amp;#91;3 4&amp;#93;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;partition-by list
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;해답이 간단하게 되어 있는 것을 보니 몇번 수정을 거쳐서 만들어낸 답이라고 생각한다. 문제를 보고 해결을 하는데 있어서 세부적인 방법 즉, &lt;strong&gt;다른 값이 나올때 앞의 값들을 묶는다&lt;/strong&gt;로 생각을 하는 방법이 있겠지만 &lt;strong&gt;같은 값을 묶는다&lt;/strong&gt;로 생각하는 방향으로 점점 생각을 바꿔나가야 한다고 생각한다. partition-by가 그러한 함수이고, list로 변환까지 하는 방법으로 사용을 했다.&lt;/p&gt;
</description>
<pubDate>
Sun, 03 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-02-4clojure-30.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-02-4clojure-30.html
</link>
<title>
4clojure - Compress a Sequence (30)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;apply str &amp;#40;&amp;#95;&amp;#95; &amp;quot;Leeeeeerrroyyy&amp;quot;&amp;#41;&amp;#41; &amp;quot;Leroy&amp;quot;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 1 2 3 3 2 2 3&amp;#93;&amp;#41; '&amp;#40;1 2 3 2 3&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;#91;1 2&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93; &amp;#91;1 2&amp;#93;&amp;#93;&amp;#41; '&amp;#40;&amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93; &amp;#91;1 2&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;
&amp;#40;fn &amp;#91;l&amp;#93;
  &amp;#40;loop &amp;#91;li &amp;#91;&amp;#93; li2 l&amp;#93;
    &amp;#40;cond &amp;#40;empty? li2&amp;#41; li
          &amp;#40;not= &amp;#40;last li&amp;#41; &amp;#40;first li2&amp;#41;&amp;#41; &amp;#40;recur &amp;#40;conj li &amp;#40;first li2&amp;#41;&amp;#41; &amp;#40;rest li2&amp;#41;&amp;#41;
          :else &amp;#40;recur li &amp;#40;rest li2&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;recur을 이용하여 li에 있는 마지막 값과 li2의 처음 값을 비교 하여 다르면 li에 추가하고 같으면 건너뛰는 방식으로 문제를 해결 하였다.&lt;/p&gt;&lt;p&gt;partition-by를 이용하는 방법도 있었는데 함수의 용도가 string 또는 collection을 순회 하면서 순서대로 같은 값 또는 같은 구조를 묶는 함수이다.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;partition-by identity &amp;#91;1 1 2&amp;#93;&amp;#41;
;; &amp;#40;&amp;#40;1 1&amp;#41; &amp;#40;2&amp;#41;&amp;#41;

&amp;#40;partition-by identity &amp;#91;1 2 1&amp;#93;&amp;#41;
;; &amp;#40;&amp;#40;1&amp;#41; &amp;#40;2&amp;#41; &amp;#40;1&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;공식 document의 예제를 변형해서 좀 더 partition-by의 용도를 확인 해봤다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;partition-by #&amp;#40;&amp;gt; 3 %&amp;#41; &amp;#91;1 2 3 4 5&amp;#93;&amp;#41;
;; &amp;#40;&amp;#40;1 2&amp;#41; &amp;#40;3 4 5&amp;#41;&amp;#41;

&amp;#40;partition-by #&amp;#40;&amp;lt; 3 %&amp;#41; &amp;#91;1 2 3 4 5&amp;#93;&amp;#41;
;; &amp;#40;&amp;#40;1 2 3&amp;#41; &amp;#40;4 5&amp;#41;&amp;#41;

&amp;#40;partition-by #&amp;#40;&amp;gt; 3 %&amp;#41; &amp;#91;1 2 3 4 5 6 7 8 9&amp;#93;&amp;#41;
;; &amp;#40;&amp;#40;1 2&amp;#41; &amp;#40;3 4 5 6 7 8 9&amp;#41;&amp;#41;

&amp;#40;partition-by #&amp;#40;= 3 %&amp;#41; &amp;#91;1 2 3 4 5 6 7 8 9&amp;#93;&amp;#41;
;; &amp;#40;&amp;#40;1 2&amp;#41; &amp;#40;3&amp;#41; &amp;#40;4 5 6 7 8 9&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;collection 값의 갯수에 따라서 묶이는 갯수가 다르다는 것을 확인 할 수 있어서 partition-all과는 동작이 다르다는 것을 알 수 있다.&lt;/p&gt;&lt;p&gt;partition-by의 원형이 되는 partition에 대해서도 테스트를 해봤다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;partition 4 &amp;#40;range 17&amp;#41;&amp;#41;
;; &amp;#40;&amp;#40;0 1 2 3&amp;#41; &amp;#40;4 5 6 7&amp;#41; &amp;#40;8 9 10 11&amp;#41; &amp;#40;12 13 14 15&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;언뜻 보기에는 partition-all과 다를바가 없어 보이는데 같은 방식으로 결과를 확인 해봤다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;partition-all 4 &amp;#40;range 17&amp;#41;&amp;#41;
;; &amp;#40;&amp;#40;0 1 2 3&amp;#41; &amp;#40;4 5 6 7&amp;#41; &amp;#40;8 9 10 11&amp;#41; &amp;#40;12 13 14 15&amp;#41; &amp;#40;16&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;마지막 값에 대해서 차이점이 있는 것을 확인 할 수 있었다. partion는 묶는 갯수에 따라서 마지막에 그 조건을 충족하지 않으면 버리지만, partition-all은 유지를 한다는 것이 차이점이다.&lt;/p&gt;
</description>
<pubDate>
Sat, 02 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-01-4clojure-29.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-01-4clojure-29.html
</link>
<title>
4clojure - Get the Caps (29)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;quot;HeLlO, WoRlD!&amp;quot;&amp;#41; &amp;quot;HLOWRD&amp;quot;&amp;#41;

&amp;#40;empty? &amp;#40;&amp;#95;&amp;#95; &amp;quot;nothing&amp;quot;&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;quot;$#A&amp;#40;&amp;#42;&amp;amp;987Zf&amp;quot;&amp;#41; &amp;quot;AZ&amp;quot;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;fn &amp;#91;s&amp;#93;
  &amp;#40;apply str &amp;#40;filter #&amp;#40;Character/isUpperCase %&amp;#41; s&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;문자 중에서 대문자인 문자만 찾아서 문자열로 만드는 문제이다.  java lib를 이용하여 대문자를 필터링 하여 문제를 해결 하였다.&lt;/p&gt;&lt;p&gt;정규식을 이용하여 필터링 하는 방법도 있다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;#&amp;#40;apply str &amp;#40;re-seq #&amp;quot;&amp;#91;A-Z&amp;#93;&amp;quot; %&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
<pubDate>
Fri, 01 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-31-4clojure-28.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-31-4clojure-28.html
</link>
<title>
4clojure - Flatten a Sequence (28)
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;&amp;#40;1 2&amp;#41; 3 &amp;#91;4 &amp;#91;5 6&amp;#93;&amp;#93;&amp;#41;&amp;#41; '&amp;#40;1 2 3 4 5 6&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;quot;a&amp;quot; &amp;#91;&amp;quot;b&amp;quot;&amp;#93; &amp;quot;c&amp;quot;&amp;#93;&amp;#41; '&amp;#40;&amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot;&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;&amp;#40;&amp;#40;&amp;#40;:a&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41; '&amp;#40;:a&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;제한: flatten&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;fn myflatten &amp;#91;x&amp;#93;
  &amp;#40;cond &amp;#40;not &amp;#40;sequential? x&amp;#41;&amp;#41; &amp;#40;list x&amp;#41;
        &amp;#40;empty? x&amp;#41; nil
        :else &amp;#40;concat &amp;#40;myflatten &amp;#40;first x&amp;#41;&amp;#41; &amp;#40;myflatten &amp;#40;rest x&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;번호 순서 대로 과거에 풀었던 문제들을 다시 정리를 하면서 분석을 하고 있다. 중첩collection을 없애고 하나의 collection으로 만드는 문제인데 concat과 sequential?로 문제를 풀었다. 기본적으로 concat은 collection에 대해서 합쳐지는 것 같아서 (list)로 만들어 반환을 해주고 있다. 이때 당시에 이 문제를 풀때 위와 같은 형태의 recursive아니면 답이 없다고 생각을 했는데 clojure라면 더 나은 답이 있으리라 판단이 든다.&lt;/p&gt;
</description>
<pubDate>
Thu, 31 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-30-4clojure-27.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-30-4clojure-27.html
</link>
<title>
4clojure - Palindrome Detector (27)
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;false? &amp;#40;&amp;#95;&amp;#95; '&amp;#40;1 2 3 4 5&amp;#41;&amp;#41;&amp;#41;

&amp;#40;true? &amp;#40;&amp;#95;&amp;#95; &amp;quot;racecar&amp;quot;&amp;#41;&amp;#41;

&amp;#40;true? &amp;#40;&amp;#95;&amp;#95; &amp;#91;:foo :bar :foo&amp;#93;&amp;#41;&amp;#41;

&amp;#40;true? &amp;#40;&amp;#95;&amp;#95; '&amp;#40;1 1 3 3 1 1&amp;#41;&amp;#41;&amp;#41;

&amp;#40;false? &amp;#40;&amp;#95;&amp;#95; '&amp;#40;:a :b :c&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x&amp;#93; &amp;#40;= &amp;#40;seq x&amp;#41; &amp;#40;reverse x&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;앞으로 봐도, 뒤에서 봐도 같은 Palindrome 검증 문제 이다. 그동안은 정말 뭔가 세부적인 것에 대한 코드를 작성을 하려고 했었는데 좀 더 좋은 방법이 없을까? 고민하다가 저 값이 결국에는 뒤집었을 때 같으면 된다는 것을 알게 되었다.&lt;/p&gt;
</description>
<pubDate>
Wed, 30 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-29-4clojure-26.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-29-4clojure-26.html
</link>
<title>
4clojure - Fibonacci Sequence (26)
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 3&amp;#41; '&amp;#40;1 1 2&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 6&amp;#41; '&amp;#40;1 1 2 3 5 8&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 8&amp;#41; '&amp;#40;1 1 2 3 5 8 13 21&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x&amp;#93;
  &amp;#40;loop &amp;#91;li &amp;#91;1 1&amp;#93; cnt 2&amp;#93;
    &amp;#40;if &amp;#40;= cnt x&amp;#41; li
      &amp;#40;recur &amp;#40;conj li &amp;#40;+ &amp;#40;last li&amp;#41; &amp;#40;last &amp;#40;take &amp;#40;- &amp;#40;count li&amp;#41; 1&amp;#41; li&amp;#41;&amp;#41;&amp;#41;&amp;#41; &amp;#40;+ cnt 1&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;피보나치 수열을 구하는 문제이다. 어떻게든 문제를 풀어보겠다고 길게 써놓은 프로그램을 보고 있자니 많은 생각이 든다. 좀 더 clojure 다운 프로그램을 만들고 싶다는 것과 좀 더 공부를 더 해야겠다는 느낌에 대해 만감이 교차 한다. 결과적으로는 문제는 해결을 했지만 여기에 만족하고 싶지는 않다.&lt;/p&gt;&lt;p&gt;iterate를 가지고 문제를 해결하는 방법이 있었는데 iterate라는 함수의 특성을 이용한 방식으로 해결을 하였다 그리고 단순한 값에 대한 결과값이 당연히 그렇게 되는 것이라고 생각을 했었는데 다른 차원의 해결 방식을 보고 iterate에 대한 사용법을 다시 한번 알게 되었다.&lt;/p&gt;&lt;p&gt;단순한 값에 대한 예제이다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;iterate inc 5&amp;#41;
;; &amp;#40;5 6 7 8 9 10 11 12 13 14 15 ... n&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;위 예제만 봤을 때는 5부터 시작해서 하나씩 증가되는 것이구나 라고 생각을 했었고 별 의심을 하지 않았다 하지만 피보나치 수열에서의 사용법을 보고 경악을 하고 말았다.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;take 3 &amp;#40;iterate &amp;#40;fn &amp;#91;&amp;#91;f s&amp;#93;&amp;#93; &amp;#91;s &amp;#40;+ f s&amp;#41;&amp;#93;&amp;#41; &amp;#91;1 1&amp;#93;&amp;#41;&amp;#41;
;; &amp;#40;&amp;#91;1 1&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;2 3&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;피보나치 수열의 결과가 나오는 과정의 일부분을 가져 왔는데 여기서 왜 s의 값이 변하는가? 에 대해서 의문을 가지고 생각을 해봤고 동작에 대해서 생각지도 못한 방식에 경악을 하고 말았고 나의 얕은 지식에 한탄 하고 말았다. 왜냐하면 처음 시작 할때 [1 1]로 시작을 하고 다음 순서에서는 [1 1]을 사용을 하는 것이 아니라 [s (+ f s)]의 값을 사용을 하는 것이 iterate의 동작이라는 것을 깨달았다. 즉 두번째 반복시 [f s]의 값은 [1 2]가 되는 것이다.&lt;/p&gt;&lt;p&gt;단순한 숫자 결과의 값에 대해서도 5부터 1개씩 증가하는구나라고 생각할 수도 있겠지만 항상 &lt;strong&gt;다음 값을 출력하기 위해서 바로 이전에 값을 사용한다는 것이 iterate의 핵심&lt;/strong&gt;이라고 느꼈다.&lt;/p&gt;&lt;p&gt;보고 있자니 왠지 reduce와 동작이 비슷한 것 같다.&lt;/p&gt;&lt;p&gt;그걸 증명해 볼수 있는 예제를 만들어 봤다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;take 5 &amp;#40;iterate identity 5&amp;#41;&amp;#41;
;; &amp;#40;5 5 5 5 5&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;identity는 어떠한 계산을 하지 않고 값 그대로를 반환하는 것인데 역시나 repeat 함수와 동작이 같았다.&lt;/p&gt;&lt;p&gt;문제를 푸는 것에 의의를 두지 말고 좀 더 함수의 사용법을 알 수 있도록 나의 생각과 예제를 통해서 공부하는 것이 더 잘 할 수 있는 방법이라는 것을 깨닫게 된 계기가 되었다.&lt;/p&gt;
</description>
<pubDate>
Tue, 29 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-28-4clojure-25.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-28-4clojure-25.html
</link>
<title>
4clojure - Find the odd numbers (25)
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; #{1 2 3 4 5}&amp;#41; '&amp;#40;1 3 5&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;4 2 1 6&amp;#93;&amp;#41; '&amp;#40;1&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;2 2 4 6&amp;#93;&amp;#41; '&amp;#40;&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 1 1 3&amp;#93;&amp;#41; '&amp;#40;1 1 1 3&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;#&amp;#40;filter odd? %&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;홀수 값을 결과로 주는 프로그램을 작성하는 문제이다. filter와 odd? 함수를 사용하여 홀수 값만 필터링이 되도록 문제를 해결 하였다.&lt;/p&gt;
</description>
<pubDate>
Mon, 28 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-27-4clojure-24.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-27-4clojure-24.html
</link>
<title>
4clojure - Sum It All Up (24)
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 2 3&amp;#93;&amp;#41; 6&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#40;list 0 -2 5 5&amp;#41;&amp;#41; 8&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; #{4 2 1}&amp;#41; 7&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;0 0 -1&amp;#41;&amp;#41; -1&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;1 10 3&amp;#41;&amp;#41; 14&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x&amp;#93;
  &amp;#40;apply + x&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;값의 총 합을 계산하는 문제이다. reduce로 풀어도 되지만 apply로 하는 것이 더 간단하게 풀리므로 apply로 계산을 하였다.&lt;/p&gt;
</description>
<pubDate>
Sun, 27 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-26-4clojure-23.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-26-4clojure-23.html
</link>
<title>
4clojure - Reverse a Sequence (23)
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 2 3 4 5&amp;#93;&amp;#41; &amp;#91;5 4 3 2 1&amp;#93;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#40;sorted-set 5 7 2 7&amp;#41;&amp;#41; '&amp;#40;7 5 2&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;#91;1 2&amp;#93;&amp;#91;3 4&amp;#93;&amp;#91;5 6&amp;#93;&amp;#93;&amp;#41; &amp;#91;&amp;#91;5 6&amp;#93;&amp;#91;3 4&amp;#93;&amp;#91;1 2&amp;#93;&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;제한: reverse, rseq&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x&amp;#93;
  &amp;#40;reduce &amp;#40;fn &amp;#91;acc e&amp;#93; &amp;#40;conj acc e&amp;#41;&amp;#41; '&amp;#40;&amp;#41; x&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;reverse, rseq를 사용하지 않고 순서를 뒤집는 동작을 작성하는 문제 이다. 나는 reduce를 사용하여 list의 conj 동작이 들어오는 순서대로 첫번째로 추가되는 원리를 이용하여 문제를 해결 하였다 into를 이용하여 문제를 푸는 방식도 있다. &lt;/p&gt;&lt;p&gt;into의 실행 방식은 결과 collection의 형태에 따라서 다르다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;into &amp;#91;&amp;#93; &amp;#91;1 2 3 4 5&amp;#93;&amp;#41;
;; &amp;#91;1 2 3 4 5&amp;#93;

&amp;#40;into &amp;#40;&amp;#41; &amp;#91;1 2 3 4 5&amp;#93;&amp;#41;
;; &amp;#40;5 4 3 2 1&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;즉, conj + collection 의 조합이다.&lt;/p&gt;&lt;p&gt;hash-map으로는 조금 다르게도 사용  가능하다&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;into {} &amp;#91;{:a 1} {:b 2}&amp;#93;&amp;#41;
;; {:a 1 :b 2}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
<pubDate>
Sat, 26 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-25-4clojure-22.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-25-4clojure-22.html
</link>
<title>
4clojure - Count a Sequence (22)
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;1 2 3 3 1&amp;#41;&amp;#41; 5&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;quot;Hello World&amp;quot;&amp;#41; 11&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93; &amp;#91;5 6&amp;#93;&amp;#93;&amp;#41; 3&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;13&amp;#41;&amp;#41; 1&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;:a :b :c&amp;#41;&amp;#41; 3&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;제한 : count 함수&lt;/strong&gt; &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x&amp;#93;
  &amp;#40;reduce &amp;#40;fn &amp;#91;acc e&amp;#93; &amp;#40;inc acc&amp;#41;&amp;#41; 0 x&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;원소의 갯수를 파악하는 문제이다 나는  reduce를 사용하여 원소를 순회하며 acc를 한개씩 증가시키는 방법으로 문제를 해결 하였다.&lt;/p&gt;&lt;p&gt;solution을 보니 or 또는 do를 사용하여 문제를 해결한 사람들도 있었다. or은 false인 경우를 제외하고 무조건 첫번째 표현식의 결과 값을 반환 한다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;or &amp;#40;inc 0&amp;#41; :a&amp;#41;
;; 1
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;위 표현식을 보면 :a는 출력을 하지 않는다는 것이다.&lt;/p&gt;&lt;p&gt;do는 표현식을 순서대로 실행하는 함수이다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;do &amp;#40;print &amp;quot;Somthing&amp;quot;&amp;#41;
	  &amp;#40;print &amp;quot;this&amp;quot;&amp;#41;&amp;#41;
;; Somthing
;; this
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
<pubDate>
Fri, 25 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-24-4clojure-21.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-24-4clojure-21.html
</link>
<title>
4clojure - Nth Element (21)
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;4 5 6 7&amp;#41; 2&amp;#41; 6&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;:a :b :c&amp;#93; 0&amp;#41; :a&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 2 3 4&amp;#93; 1&amp;#41; 2&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;&amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93; &amp;#91;5 6&amp;#93;&amp;#41; 2&amp;#41; &amp;#91;5 6&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;제한: nth&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;fn mynth &amp;#91;x cnt&amp;#93; 
	&amp;#40;if &amp;#40;= cnt 0&amp;#41; &amp;#40;first x&amp;#41; 
	&amp;#40;mynth &amp;#40;rest x&amp;#41; &amp;#40;- cnt 1&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;풀었던 문제들을 다시 정리를 하면서 좀 더 짧은 방법을 정리를 하는 것이 맞는 것인가를 생각을 하게되었지만 지금 나의 현재 실력을 보는 것도 중요하다는 생각이 들었다. 문제를 풀고 나서 해답을 보는데 왜 나는 저런 방법을 생각하지 못했을까?를 생각하게 되는 계기가 되는 것 같다. recursive를 하면서 index를 조회하여 값을 가져오는 방법으로 문제를 풀었다.&lt;/p&gt;&lt;p&gt;solution에서는 drop을 사용하여 문제를 해결하는 방식이 있었다.  drop의 용도는 첫번째부터 갯수만큼 버리는 함수이다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;drop 2 '&amp;#40;4 5 6 7&amp;#41;&amp;#41;
;; &amp;#40;6 7&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
<pubDate>
Thu, 24 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-23-4clojure-20.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-23-4clojure-20.html
</link>
<title>
4clojure - Penultimate Element (20)
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#40;list 1 2 3 4 5&amp;#41;&amp;#41; 4&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot;&amp;#93;&amp;#41; &amp;quot;b&amp;quot;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93;&amp;#93;&amp;#41; &amp;#91;1 2&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;#&amp;#40;second &amp;#40;reverse %&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;19번 문제와 비슷한 문제 이다. 언뜻 보기에는 각각 다른 위치의 원소를 가져오는 문제 처럼 보여서 헷갈렸는데 결국에는 뒤집어서 두번째 원소를 가져오는 문제라는 사실을 깨닫고 풀게 된 문제이다. 앞으로 이런 문제들이 많을 텐데 생각의 확장이 필요 한 것 같다.&lt;/p&gt;
</description>
<pubDate>
Wed, 23 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-22-4clojure-19.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-22-4clojure-19.html
</link>
<title>
4clojure - Last Element (19)
</title>
<description>
&lt;p&gt;제한 함수 : last 함수&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 2 3 4 5&amp;#93;&amp;#41; 5&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;5 4 3&amp;#41;&amp;#41; 3&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;quot;b&amp;quot; &amp;quot;c&amp;quot; &amp;quot;d&amp;quot;&amp;#93;&amp;#41; &amp;quot;d&amp;quot;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;#&amp;#40;first &amp;#40;reverse %&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;처음으로 제한을 두는 함수가 나왔다 last를 사용하지 않고 끝에 값을 가져오는 문제 이다. 많은 방법들이 있겠지만 collection 을 뒤집어서 첫번째 원소를 가져오는 방법이 가장 간단하고 생각하기 쉬운 방법으로 보인다.&lt;/p&gt;
</description>
<pubDate>
Tue, 22 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-21-4clojure-18.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-21-4clojure-18.html
</link>
<title>
4clojure 18
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;filter #&amp;#40;&amp;gt; % 5&amp;#41; '&amp;#40;3 4 5 6 7&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;'&amp;#40;6 7&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;filter에 동작에 관한 문제 이다. filter는 비교군에 대한 결과 값을 collection으로 주는 함수 이다. 따라서 결과는 ‘(6 7)이 된다.&lt;/p&gt;
</description>
<pubDate>
Mon, 21 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-20-4clojure-17.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-20-4clojure-17.html
</link>
<title>
4clojure 17
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;map #&amp;#40;+ % 5&amp;#41; '&amp;#40;1 2 3&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;'&amp;#40;6 7 8&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;map은 기본적으로 for구문과 유사하지만 collection으로 반환한다는 특성을 가지고 있다. 내부의 +5를 하는 익명 함수를 거쳐서 나오는 답은 ‘(6 7 8) 이다.&lt;/p&gt;
</description>
<pubDate>
Sun, 20 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-19-4clojure-16.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-19-4clojure-16.html
</link>
<title>
4clojure 16
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;quot;Dave&amp;quot;&amp;#41; &amp;quot;Hello, Dave!&amp;quot;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;quot;Jenn&amp;quot;&amp;#41; &amp;quot;Hello, Jenn!&amp;quot;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;quot;Rhea&amp;quot;&amp;#41; &amp;quot;Hello, Rhea!&amp;quot;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;#&amp;#40;str &amp;quot;Hello, &amp;quot; % &amp;quot;!&amp;quot;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;15번 문제와 비슷하게 함수의 실행에 대한 문제 및 string 활용 문제 이다. clojure에서는 string의 조합을 할 때 str 함수를 사용하고 어떠한 기호도 붙이지 않고 띄어쓰기로 문장의 결합이 가능하다. &lt;/p&gt;
</description>
<pubDate>
Sat, 19 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-18-4clojure-15.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-18-4clojure-15.html
</link>
<title>
4clojure 15
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 2&amp;#41; 4&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 3&amp;#41; 6&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 11&amp;#41; 22&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 7&amp;#41; 14&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;#&amp;#40;&amp;#42; % 2&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;문제들의 값은 기본적으로 2 * ? 의 결과를 나타내주고 있다. 그래서 clojure에서는 함수를 만들고 바로 실행을 할 수 있는 방법으로 표현을 했다. &lt;/p&gt;
</description>
<pubDate>
Fri, 18 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-17-4clojure-14.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-17-4clojure-14.html
</link>
<title>
4clojure 14
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;&amp;#40;fn add-five &amp;#91;x&amp;#93; &amp;#40;+ x 5&amp;#41;&amp;#41; 3&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;&amp;#40;fn &amp;#91;x&amp;#93; &amp;#40;+ x 5&amp;#41;&amp;#41; 3&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;#&amp;#40;+ % 5&amp;#41; 3&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;&amp;#40;partial + 5&amp;#41; 3&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;clojure에서는 기본적으로 익명 함수를 만드는 방법이 2가지가 있다. fn으로 시작하는 방법, # 으로 시작하는 방법, 2가지가 있고 partial은 미리 공통된 수식을 정의 하는 함수로써 공통된 작업을 미리 정의할 때 사용하는 함수이다. 그래서 8일때 4개의 등식은 성립한다.&lt;/p&gt;
</description>
<pubDate>
Thu, 17 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-16-4clojure-13.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-16-4clojure-13.html
</link>
<title>
4clojure 13
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;rest &amp;#91;10 20 30 40&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#91;20 30 40&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;clojure에서는 lisp에서 제공 하는 함수들을 기본 제공 한다 rest도 마찬가지로 lisp에서 제공하는 기능 그대로의 역할을 한다. rest는 처음 값을 뺀 나머지 값이므로 [20 30 40] 이다.&lt;/p&gt;
</description>
<pubDate>
Wed, 16 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-15-4clojure-12.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-15-4clojure-12.html
</link>
<title>
4clojure 12
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;first '&amp;#40;3 2 1&amp;#41;&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;second &amp;#91;2 3 4&amp;#93;&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;last &amp;#40;list 1 2 3&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;clojure에서는 원소를 접근 할 수 있는 squense 함수들을 제공 한다. first, second, last 단어 그대로 해석을 하면 되고 첫번째, 두번째, 마지막 원소를 가져온다 그러므로 3의 값이 성립한다.&lt;/p&gt;
</description>
<pubDate>
Tue, 15 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-14-4clojure-11.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-14-4clojure-11.html
</link>
<title>
4clojure 11
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= {:a 1, :b 2, :c 3} &amp;#40;conj {:a 1} &amp;#95;&amp;#95; &amp;#91;:c 3&amp;#93;&amp;#41;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#91;:b 2&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;기본적으로 hash-map에서의 conj 사용은 하나의 hash-map으로 합치는 용도로 사용되는 것 같다. vector로 하는 것 뿐만 아니라 {}로도 가능하다 하지만 ‘()로는 되지 않는 것으로 확인 되었다.&lt;/p&gt;
</description>
<pubDate>
Mon, 14 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-13-4clojure-10.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-13-4clojure-10.html
</link>
<title>
4clojure 10
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;&amp;#40;hash-map :a 10, :b 20, :c 30&amp;#41; :b&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;:b {:a 10, :b 20, :c 30}&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;20
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;python의 dictionary 자료형과 동일한 역할을 한다 clojure에서는 hash-map이라는 용어를 사용하고 만드는 방법은 위와 같이 {}에 :a 형태의 key와 value를 추가하여 생성한다. 위 문제에서는 :b key의 값을 가져오는 방법을 보여주고 있다. ({} :b)의 형태, (:b {})의 형태 모두 :b의 값을 가져오는 역할을 한다. 답은 20이다.&lt;/p&gt;
</description>
<pubDate>
Sun, 13 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-12-4clojure-09.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-12-4clojure-09.html
</link>
<title>
4clojure 09
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= #{1 2 3 4} &amp;#40;conj #{1 4 3} &amp;#95;&amp;#95;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;집합은 기본적으로 순서를 가지지 않는다. 순서가 달라도 같은 집합으로 인식을 하고, conj 함수의 동작은 마지막에 값을 추가한다. 따라서 2 값으면 성립을 한다.&lt;/p&gt;
</description>
<pubDate>
Sat, 12 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-11-4clojure-08.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-11-4clojure-08.html
</link>
<title>
problem 08
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;set '&amp;#40;:a :a :b :c :c :c :c :d :d&amp;#41;&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;clojure.set/union #{:a :b :c} #{:b :c :d}&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;#{:a :b :c :d}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;set이라는 자료형은 집합이다. 수학의 집합 관련 연산은 무엇이든 가능하며, 중복된 값을 제거 하는 역할을 가지고 있다. union은 합집합의 기능을 한다. 집합기호는 기본적으로#{} 형태로 나타내며 # {:a :b :c :d} 로 성립한다.&lt;/p&gt;
</description>
<pubDate>
Fri, 11 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-10-4clojure-07.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-10-4clojure-07.html
</link>
<title>
problem 07
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;conj &amp;#91;1 2 3&amp;#93; 4&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;conj &amp;#91;1 2&amp;#93; 3 4&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#91;1 2 3 4&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;vector의 conj는 list와 다르게 마지막에 값을 추가한다 그러므로 [1 2 3 4] 이다.&lt;/p&gt;
</description>
<pubDate>
Thu, 10 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-09-4clojure-06.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-09-4clojure-06.html
</link>
<title>
problem 06
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#91;&amp;#95;&amp;#95;&amp;#93; &amp;#40;list :a :b :c&amp;#41; &amp;#40;vec '&amp;#40;:a :b :c&amp;#41;&amp;#41; &amp;#40;vector :a :b :c&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:a :b :c
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; vector 자료형이다. vector를 생성하는 방법에 대해서 보여주고 있다. 중간에 vec은 list 자료형을 받으면 vector로 변환하는 함수이다. 기본적으로 내용이 같으면 vector, list는 서로 같다 그러므로 :a :b :c이면 성립힌다.&lt;/p&gt;
</description>
<pubDate>
Wed, 09 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-08-4clojure-05.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-08-4clojure-05.html
</link>
<title>
problem 05
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;conj '&amp;#40;2 3 4&amp;#41; 1&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;conj '&amp;#40;3 4&amp;#41; 2 1&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;'&amp;#40;1 2 3 4&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;처음으로 테스트를 통과해야하는 문제가 2개가 되었다. conj는 list 자료형인 경우 앞에 값을 추가를 한다, 2개가 있는 경우 앞에 값부터 차례로 값을 앞으로 추가를 한다. stack이라고 생각하면 쉬울 것 같다. 그러므로’(1 2 3 4)이면 등호를 만족 한다.&lt;/p&gt;
</description>
<pubDate>
Tue, 08 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-07-4clojure-04.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-07-4clojure-04.html
</link>
<title>
problem 04
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;list &amp;#95;&amp;#95;&amp;#41; '&amp;#40;:a :b :c&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:a :b :c
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;clojure에서 리스트를 만드는 방법이 여러가지 가 있는데 ‘()로 만드는 방법 (list)로 만드는 방법이 있다. 위 문제는 두가지 방법을 사용하였고 list안에 만족하는 답을 넣어주면 된다. 답은 :a :b :c 이다.&lt;/p&gt;
</description>
<pubDate>
Mon, 07 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-06-4clojure-03.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-06-4clojure-03.html
</link>
<title>
problem 03
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;.toUpperCase &amp;quot;hello world&amp;quot;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;quot;HELLO WORLD&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;clojure에서는 기본적으로 자바의 라이브러리를 사용할 수 있다. 마찬가지로 string에 대한 함수를 호출 할 수 있는데 자바와는 반대로 위와같은 방법으로 호출을 하여 사용 할 수 있다. “HELLO WORLD”로 하면 성립이 된다.&lt;/p&gt;
</description>
<pubDate>
Sun, 06 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-05-4clojure-02.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-05-4clojure-02.html
</link>
<title>
problem 02
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;- 10 &amp;#40;&amp;#42; 2 3&amp;#41;&amp;#41; &amp;#95;&amp;#95;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;중간의 계산식에 대한 답을 넣으면 된다 기본적으로 lisp은 안에서 부터 밖으로 계산이 되므로 풀어서 쓴다면 10 - (2 * 3)의 계산 결과가 된다. 4로 하면 등호가 성립이 된다.&lt;/p&gt;
</description>
<pubDate>
Sat, 05 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-04-4clojure-01.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-04-4clojure-01.html
</link>
<title>
problem 01
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; true&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;__ 안에 어떤 값을 넣어야 =를 만족 할수 있는지 부터가 4clojure의 시작이다 true를 넣으면 값이 성립 한다.&lt;/p&gt;
</description>
<pubDate>
Fri, 04 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-03-4clojure-start.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-03-4clojure-start.html
</link>
<title>
4clojure 정리
</title>
<description>
&lt;p&gt;clojure 언어를 좋아한다고 해놓고선 아무런 공부의 기록이 없다는 것이 말이 안된다는 생각이 들었다.&lt;/p&gt;&lt;p&gt;그래서 기존에 했던 내용들을 복습을 할 겸 1개씩 정리를 하려고 한다.&lt;/p&gt;&lt;p&gt;쉬운 내용이면 쉽게 가고 좀 생각을 해야할 내용이면 생각 정리와 동시에 시도했던 내용들을 정리를 한다.&lt;/p&gt;
</description>
<pubDate>
Thu, 03 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-02-stop-retention.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-02-stop-retention.html
</link>
<title>
리텐션이 낮고 사용자가 감소 또는 유지된다는 것은?
</title>
<description>
&lt;p&gt;마케팅비용을 사용하면서 사용자의 관심을 단기간에 끌긴 하지만 단기간이라고 한다면 증가세가 아니라면 난 제품에 문제가 있다고 생각한다 제품이 좋고, 나의 불편한점을 해결한다면 안쓸이유가 없기 때문이다 사용자는 자신의 불편함을 해결해 주는 제품에 돈을 지불한다&lt;/p&gt;&lt;p&gt;지금 리텐션이 낮고 사용자가 감소 또는 유지가 된다는 것은 내부 직원이 아무런 활동을 하지 않아서가 아니라 애초에 지금의 앱이 사용자의 문제를 해결하지 못한다는 반증이 될 수도 있다 사용자에게 별 필요가 없는 제품이라는 뜻이다 &lt;/p&gt;&lt;p&gt;단기간에 사용자의 리텐션을 올리기 위해 푸시를 자주 보내는 것이 맞는 것인가? 아니면 어떤 불편함을 해결하기 위해서 고민을 하는 것이 맞는 것인가?   &lt;/p&gt;&lt;p&gt;둘다 하는 것이 맞겠지만 리소스는 한정이 되어 있으므로 한정된 리소스 안에서 절충안은 필요하다고 생각한다.&lt;/p&gt;
</description>
<pubDate>
Wed, 02 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-01-think-in-box.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-01-think-in-box.html
</link>
<title>
틀안에서 생각한다는 것의 의미
</title>
<description>
&lt;p&gt;혁신이라고 하는 것은 아무 것도 없는 것에서 생기지 않는다고 생각한다 현재의 환경에서 어떻게 한발 더 나아지는지를 고민하는 것이 혁신이라고 생각하고 현재의 리소스를 어떻게 최대한 활용을 할 것인지가 혁신이라고 생각한다&lt;/p&gt;&lt;p&gt;보통은 무엇이 더 나아지면 할 수 있는데 무엇이 더 나아지면 좋아지는데 라는 생각들을 많이 하곤한다 근데 그런 생각들이 오히려 더 나아질 수 있는 것을 방해하는 것이라고 생각 한다&lt;/p&gt;&lt;p&gt;어떠한 단점들만 말하는 것 보다는 그 것들을 해결하기 위해서 지금 내가 할 수 있는 일을 생각하는 것이 더 나아지는 방향이라고 생각한다&lt;/p&gt;
</description>
<pubDate>
Tue, 01 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-09-30-think-extend.html
</guid>
<link>
http://dev-happy.com/posts/2019-09-30-think-extend.html
</link>
<title>
확장성이라는 것에 대한 생각
</title>
<description>
&lt;p&gt;과자를 하나 사러 동네 슈퍼를 갔다가 집으로 돌아가는 중이다 집에서 어머니가 오는길에 고기를 사오라고 한다면? 어떠한 반응을 보여야 할까? 왜 지금 얘기하는지 화내야 할까? 아니면 첨부터 동네 슈퍼를 간 내 탓일까?&lt;/p&gt;&lt;p&gt;어떠한 경우라도 상황이라는 것이 내가 원하는데로만 생각한데로만 될순 없다고 생각한다&lt;/p&gt;&lt;p&gt;그렇다고 모든 경우의 수를 고려해서 할 수도 없다 그렇다면 어떻게 해야할까?&lt;/p&gt;&lt;p&gt;마음으로라도 상황이 수시로 변한다는 것을 인정을 하면서 대응을 하는 것이 맞다고 생각한다&lt;/p&gt;&lt;p&gt;단적이었지만 개발하는 상황에서도 일어날 수 있는 일이다 확정적으로 무언가를 항상 할 수는 없다 시시때때로 변화하는 환경에 내가 잘 대응할 수 있도록 만드는 것이 중요한 것 같다&lt;/p&gt;
</description>
<pubDate>
Mon, 30 Sep 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-09-27-how-db-select.html
</guid>
<link>
http://dev-happy.com/posts/2019-09-27-how-db-select.html
</link>
<title>
RDB select에 대한 고찰
</title>
<description>
&lt;p&gt;개발을 하다보면 rdb는 필수로 사용을 하게 된다 &lt;/p&gt;&lt;p&gt;그렇지만 rdb에 있는데이터의 구조를 확장성 있게 사용한다는 것은 또다른 어려움이 있다고 생각한다&lt;/p&gt;&lt;p&gt;rdb 구조를 잘 설계하면 확장성있게 사용 가능한가?라는 질문에는 아니오라고 얘기하고 싶다 그 이유는 2차원으로 사용하는 rdb의 특성상 원하는 구조로 다시 바꾸기란 쉽지만은 않기때문이다&lt;/p&gt;&lt;p&gt;원하는 데이터를 전송할때도 전송할 데이터에 대한 구조만 작성을 하는 것이 확장성이 있을까 하면 아니오이고 필히 수정 또는 확장을 요구하는 현상이 반드시 일어난다고 생각한다&lt;/p&gt;&lt;p&gt;내가 하고 싶은 것은 테이블 전체의 데이터 구조들을 정의 해놓고 select를 하고 원하는 데이터만 선택적으로 전송한다면 변화에는 유용하리라 생각한다&lt;/p&gt;&lt;p&gt;아직 그렇게 작성을 해보진 않아서 얼마나 속도에 영향이 있을지는 모르겠지만 시도해볼만 하다고 생각한다&lt;/p&gt;&lt;p&gt;다시 생각을 해보니 너무 rdb 설계에 의존을 하는 것은 않좋다는 생각이 들었다. db를 먼저 설계 하고 클래스를 설계를 하게 되니 확장성이 안그래도 없는데 더 없어졌다는 생각이 들었고 db를 설계하기 전에 class를 설계하는 습관이 필요하다는 생각이 들었다. 그래야 test 코드도 원하는데로 만들수 있고, 확장 및 변경에 용이하리라 생각한다.&lt;/p&gt;&lt;p&gt;db 보다는 domain이 중요하다.&lt;/p&gt;
</description>
<pubDate>
Fri, 27 Sep 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-09-26-sql-vs-java.html
</guid>
<link>
http://dev-happy.com/posts/2019-09-26-sql-vs-java.html
</link>
<title>
SQL query VS java (프로그래밍 언어)
</title>
<description>
&lt;p&gt;java는 알고 있었지만 server 개발을 하면서 query 작성만으로 충분하다고 생각 했었다. 하지만 요즘은 java 로직을 어떻게 작성을 해야할지 더 신경을 쓰게 된다.&lt;/p&gt;&lt;p&gt;매일매일이 다른 변화를 대응을 해야하다보니 query만으로는 한계를 많이 느꼈고 확장성과 유연함을 위해서는 구조 설계 및 아키텍처 설계 능력의 필요성을 자연스럽게 느끼게 되었다.&lt;/p&gt;&lt;p&gt;그래서 최소한으로 db 데이터를 가져 오고,  java 로직에서 더 가공을 할 수 있는 쪽으로 server는 점점 발전을 해 나가고 있다.&lt;/p&gt;&lt;p&gt;프로그래밍의 발전 성향으로 봤을 때도 query쪽으로, db쪽으로 발전을 하기 보다는 server 로직 단에서 더 발전을 하고 있음을 몸소 느끼는 중이다.&lt;/p&gt;&lt;p&gt;Server 부하 관리를 로드 밸런싱이 생겼고, 똑같은 Server를 빠르게 생성을 하기 위해서 docker 가 탄생을 하였다.&lt;/p&gt;&lt;p&gt;Db 부하가 발생하면? db를 추가하는 것은 어려운 기술을 필요로 한다.(요즘에는 AWS에서 손쉽게 읽기 전용으로 생성이 가능하지만 Server의 확장 처럼 유연하게 확장하기는 어렵다고 생각한다.)&lt;/p&gt;&lt;p&gt;query 작성 보다는 orm 쪽으로 언어의 특성에 맞게 다양하게 발전 중이라고 생각한다.&lt;/p&gt;&lt;p&gt;query는 정적이다. 동적으로 무언가를 하기가 어렵고, 서비스를 하는 입장에서 확장을 위해서라면 아키텍처 설계는 필수라는 것을 몸소 체감하고 있다.&lt;/p&gt;&lt;p&gt;한번 만들고 유지보수를 하지 않는 프로젝트라고 한다면 단일로 query를 작성하는게 나을수도 있지만 비즈니스, 서비스를 하는 회사라면 빠른 변화의 대응을 위해서는 로직 작성이 우선이 되어야 한다.&lt;/p&gt;&lt;p&gt;왜 서비스를 하는 회사들이 면접을 볼때 디자인 패턴이니, 구현상의 어려움이니 그런 질문들을 하는 이유가 왜 하는지 조금은 알 것 같다.&lt;/p&gt;&lt;p&gt;그때까지 난 query로 모든 것을 해결 하였기 때문에 어려움이 많이 없었다고 생각한다.&lt;/p&gt;&lt;p&gt;지금도 상품의 Sort 로직 작성을 생각하면서 좀 더 나은 방법이 없는지 이런 문제들은 어떻게 해결을 해야하는게 좋은지 더 나은 방법을 찾으려고 하는 것 자체가 많은 발전이라고 생각한다.(현재 서비스하는 시스템에서는 query로 해결 되어 있지만 확장성은 없다)&lt;/p&gt;&lt;p&gt;10년 이상 프로그래밍을 하였지만 아직 더 가야할 길이 먼거 같다.&lt;/p&gt;
</description>
<pubDate>
Thu, 26 Sep 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-09-25-python-reduce.html
</guid>
<link>
http://dev-happy.com/posts/2019-09-25-python-reduce.html
</link>
<title>
Python3 reduce 사용
</title>
<description>
&lt;p&gt;Python에서 어떠한 문제를 해결 하기 위해서 reduce를 사용을 하게 되었다.&lt;/p&gt;&lt;p&gt;예제에서는 list안에서 원하는 인덱스 얻기 위한 상황에서 사용을 하게 되었다. 보통은 아래와 같은 코드로 작성을 하게된다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;python
select&amp;#95;index = 0
for index, value in enumerate&amp;#40;&amp;#91;1,2,3,4,5,6,7,8&amp;#93;&amp;#41;:
	if value == 5:
		select&amp;#95;index = index
		break
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;조금 뭔가 작위적인 코드가 된거 같긴 한데 위와 비슷한 알고리즘으로 처음에 생각을 하게 되고, 개발자라면 누구나 쉽게 생각할 수 있는 코드의 구조라고 생각을 한다.&lt;/p&gt;&lt;p&gt;하지만 파이썬을 사용을 하다보니 좀 더 쉬운, 간단한 방법은 없을까?라고 생각을 하게 되었고 2번째는 아래와 같은 코드를 생각을 하게 되었다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;python
#python3에서는 아래코드 import
from functools import reduce

index = reduce&amp;#40;lambda acc, x: x if x&amp;#91;1&amp;#93; == 5 else acc, enumerate&amp;#40;&amp;#91;1,2,3,4,5,6,7,8&amp;#93;&amp;#41;&amp;#41;

index&amp;#91;0&amp;#93; # index 값 추출

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;clojure를 하다보니 reduce라는 함수는 알고 있었고 사용법이 무궁무진 하다는 것을 알고 있었기 때문에 혹시나  python에서도 이런 방법으로 할 수 있지 않을까?라는 생각을 하게 되었고 적용을 하였다.&lt;/p&gt;&lt;p&gt;설명을 한다면 lambda안에서 acc에 누적 값을 저장을 하는 방식인데 보통은 reduce를 아래와 같은 방법으로 사용을 한다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;python
#python3에서는 아래코드 import
from functools import reduce

sum = reduce&amp;#40;lambda acc, x: acc+x, &amp;#91;1,2,3,4,5,6,7,8&amp;#93;&amp;#41;
#sum의 값은 36
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;어차피 acc에는 list가 순회 할때까지 조건에 맞는 값을 유지 할 수 있을 것 같아서 사용을 하게 되었다.&lt;/p&gt;&lt;p&gt;지금은 리팩토링을 하다보니 reduce 코드보다는 dictionary로 변경을 하여 사용하고 있지만 reduce의 기록을 위해서 남겨둔다.&lt;/p&gt;
</description>
<pubDate>
Wed, 25 Sep 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-09-24-experience-python.html
</guid>
<link>
http://dev-happy.com/posts/2019-09-24-experience-python.html
</link>
<title>
Python을 2년 사용해 보고
</title>
<description>
&lt;p&gt;2016년에 본격적으로 사용을 해서 최근까지 웹, 스크립트로 사용을 하고 있다. 처음에는 문법적인 어색함이 커서 적응을 하기 힘들었으나 하면 할 수록 생산성이 올라가는데 일조를 한다는 것을 알게 되었다.&lt;/p&gt;&lt;p&gt;특히, 지금 회사에서 본격적으로 귀찮은 업무들을 모두 Python으로 사용을 하면서 그 매력을 더 잘 느낄 수 있었다.&lt;/p&gt;&lt;p&gt;쉬운 문법 덕분인지는 모르겠지만 무언가 생각을 바로바로 구현을 해보고 테스트를 해보는 것이 장점으로 다가 왔던 것 같다.&lt;/p&gt;&lt;p&gt;무엇보다 더 짧은 방법 더 간결한 방법을 생각을 하게 된다는 것에서 매력을 느꼈다. 사실 다른 언어도 마찬가지일 수 있겠지만 고착화된 언어를 사용하게 되다보면 문법적인 한계로 인하여  더 개선을 해야한다는 의지가 생기진 않는 것 같다.&lt;/p&gt;
</description>
<pubDate>
Tue, 24 Sep 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2018-02-07-why-clojure-blog.html
</guid>
<link>
http://dev-happy.com/posts/2018-02-07-why-clojure-blog.html
</link>
<title>
왜 클로저로 블로그를 만들었는가?
</title>
<description>
&lt;h3 id=&quot;들어가며&quot;&gt;들어가며&lt;/h3&gt;&lt;p&gt; 클로저를 선택하게 된 이유와 왜 클로저로 블로그를 만들었는지에 대한 설명을 한다.&lt;/p&gt;&lt;h3 id=&quot;클로저를&amp;#95;선택하게&amp;#95;된&amp;#95;이유&quot;&gt;클로저를 선택하게 된 이유&lt;/h3&gt;&lt;p&gt; 흔하디 흔한 함수형 프로그래밍과 불변 등등의 특징은 인터넷으로 찾아보면 다 나오므로 개인적으로 선택을 하게 된 이유를 작성을 한다.&lt;br /&gt;&lt;/p&gt;&lt;p&gt; 처음 프로그래밍을 시작하게 되었을 때 C, C++로 하였는데 그 때부터 왜 내 생각을 바로 표현을 할 수가 없는지에 대한 의문을 품게 되었다.&lt;/p&gt;&lt;p&gt; 그런 의문은 업무에 시달리고 바쁘다 보니 잊어버리고 살았었는데 scheme을 접하게 되면서 다시 그 의문들을 다시 생각하게 되었다.&lt;br /&gt;&lt;/p&gt;&lt;p&gt; 물론 완벽하게 내 생각을 표현을 그대로 할 수는 없겠지만 추상성이 높다보니 그래도 만족을 하면서 공부를 하게 되었다.&lt;br /&gt;&lt;/p&gt;&lt;p&gt; 하지만 수 없이 많은 라이브러리들을 바로 사용을 할 수가 없었고 그래서 JAVA와 연동이 가능한 clojure를 선택을 하게 되었다.&lt;/p&gt;&lt;p&gt; 이 글을 쓰고 있는 시점의 나는 아직 LISP 풋내기에 불과 하지만 언젠가는 내 것을 만들 것이라는 희망을 품고 있다.&lt;/p&gt;&lt;p&gt; 컴퓨터 내부가 어떻게 돌아가는지에 대한 생각에 빠져서 살다보니 어느순간 내 생각은 컴퓨터화가 되어 가고 있다는 것을 느끼게 되었다.&lt;/p&gt;&lt;p&gt; 그래서 좀 더 고차원적으로 생각을 하고 싶어서 LISP을 공부를 하는 이유도 있다.&lt;/p&gt;&lt;p&gt; 다른 사람들은 어떻게 생각 할 지는 잘 모르겠지만 개인적인 생각으로 그렇게 느끼게 되어 정리를 하고 싶어서 작성을 하였다.&lt;/p&gt;&lt;h3 id=&quot;클로저로&amp;#95;블로그를&amp;#95;만든&amp;#95;이유&quot;&gt;클로저로 블로그를 만든 이유&lt;/h3&gt;&lt;p&gt; 업무 외의 시간에 무언가 스스로 만들고 싶어서라는 이유가 크다.&lt;br /&gt;  물론 framework는 내가 만든건 아니지만 워낙 작다보니 추가적인 기능들을 추가하기가 쉽다는 것도 장점일 수 있을 것 같다.&lt;/p&gt;
</description>
<pubDate>
Wed, 07 Feb 2018 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2018-01-27-first-post.html
</guid>
<link>
http://dev-happy.com/posts/2018-01-27-first-post.html
</link>
<title>
클로저로 된 블로그 생성
</title>
<description>
&lt;h3 id=&quot;블로그에&amp;#95;작성을&amp;#95;할&amp;#95;글&quot;&gt;블로그에 작성을 할 글&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;새롭게 알게 된 내용 정리&lt;/li&gt;&lt;li&gt;독서 감상문&lt;/li&gt;&lt;li&gt;알고 있는 내용 정리&lt;/li&gt;&lt;li&gt;블로그 테마 수정&lt;/li&gt;&lt;li&gt;알고리즘 문제 풀이&lt;/li&gt;&lt;li&gt;블로그 코드 수정하여 기능 추가&lt;/li&gt;&lt;li&gt;이력서 정리&lt;/li&gt;&lt;li&gt;등등&lt;/li&gt;&lt;/ul&gt;
</description>
<pubDate>
Sat, 27 Jan 2018 00:00:00 +0900
</pubDate>
</item>
</channel>
</rss>
