<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://dev-happy.com/' rel='self' type='application/rss+xml'/>
<title>
Dev Happy
</title>
<link>
http://dev-happy.com/
</link>
<description>
개발 관련 경험 및 성찰들을 기록
</description>
<lastBuildDate>
Mon, 04 Nov 2019 05:53:50 +0900
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
http://dev-happy.com/posts/2019-11-04-4clojure-32.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-04-4clojure-32.html
</link>
<title>
4clojure - Duplicate a Sequence (32)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 2 3&amp;#93;&amp;#41; '&amp;#40;1 1 2 2 3 3&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;:a :a :b :b&amp;#93;&amp;#41; '&amp;#40;:a :a :a :a :b :b :b :b&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93;&amp;#93;&amp;#41; '&amp;#40;&amp;#91;1 2&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93; &amp;#91;3 4&amp;#93;&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93;&amp;#93;&amp;#41; '&amp;#40;&amp;#91;1 2&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93; &amp;#91;3 4&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;mapcat &amp;#40;fn &amp;#91;x&amp;#93; &amp;#40;list x x&amp;#41;&amp;#41;

mapcat #&amp;#40;repeat 2 %&amp;#41;

mapcat #&amp;#40;take 2 &amp;#40;iterate identity %&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;값을 하나씩 추가로 생성을 하고 collection인 경우 collection을 그대로 복사하는 문제이다. mapcat을 사용하였는데 map  + apply + concat으로 풀어서 해도 해결 가능 하다.&lt;/p&gt;&lt;p&gt;interleave를 사용하여 해결한 방식도 있었는데 같은 collection을 2번 합쳐서 해결하는 방식이 있었다.&lt;/p&gt;&lt;p&gt;interleave의 작동 방식을 테스트하는 예제를 만들어 봤다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;interleave &amp;#91;4 5 6&amp;#93; &amp;#91;1 2 3&amp;#93;&amp;#41;
;; &amp;#40;4 1 5 2 6 3&amp;#41;

&amp;#40;interleave &amp;#91;&amp;#91;4 5 6&amp;#93;&amp;#93; &amp;#91;1 2 3&amp;#93;&amp;#41;
;; &amp;#40;&amp;#91;4 5 6&amp;#93; 1&amp;#41;

&amp;#40;interleave &amp;#91;4&amp;#93; &amp;#91;1 2 3&amp;#93;&amp;#41;
;; &amp;#40;4 1&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
<pubDate>
Mon, 04 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-03-4clojure-31.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-03-4clojure-31.html
</link>
<title>
4clojure - Pack a Sequence (31)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 1 2 1 1 1 3 3&amp;#93;&amp;#41; '&amp;#40;&amp;#40;1 1&amp;#41; &amp;#40;2&amp;#41; &amp;#40;1 1 1&amp;#41; &amp;#40;3 3&amp;#41;&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;:a :a :b :b :c&amp;#93;&amp;#41; '&amp;#40;&amp;#40;:a :a&amp;#41; &amp;#40;:b :b&amp;#41; &amp;#40;:c&amp;#41;&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;#91;1 2&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93;&amp;#93;&amp;#41; '&amp;#40;&amp;#40;&amp;#91;1 2&amp;#93; &amp;#91;1 2&amp;#93;&amp;#41; &amp;#40;&amp;#91;3 4&amp;#93;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;partition-by list
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;해답이 간단하게 되어 있는 것을 보니 몇번 수정을 거쳐서 만들어낸 답이라고 생각한다. 문제를 보고 해결을 하는데 있어서 세부적인 방법 즉, &lt;strong&gt;다른 값이 나올때 앞의 값들을 묶는다&lt;/strong&gt;로 생각을 하는 방법이 있겠지만 &lt;strong&gt;같은 값을 묶는다&lt;/strong&gt;로 생각하는 방향으로 점점 생각을 바꿔나가야 한다고 생각한다. partition-by가 그러한 함수이고, list로 변환까지 하는 방법으로 사용을 했다.&lt;/p&gt;
</description>
<pubDate>
Sun, 03 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-02-4clojure-30.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-02-4clojure-30.html
</link>
<title>
4clojure - Compress a Sequence (30)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;apply str &amp;#40;&amp;#95;&amp;#95; &amp;quot;Leeeeeerrroyyy&amp;quot;&amp;#41;&amp;#41; &amp;quot;Leroy&amp;quot;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 1 2 3 3 2 2 3&amp;#93;&amp;#41; '&amp;#40;1 2 3 2 3&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;#91;1 2&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93; &amp;#91;1 2&amp;#93;&amp;#93;&amp;#41; '&amp;#40;&amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93; &amp;#91;1 2&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;
&amp;#40;fn &amp;#91;l&amp;#93;
  &amp;#40;loop &amp;#91;li &amp;#91;&amp;#93; li2 l&amp;#93;
    &amp;#40;cond &amp;#40;empty? li2&amp;#41; li
          &amp;#40;not= &amp;#40;last li&amp;#41; &amp;#40;first li2&amp;#41;&amp;#41; &amp;#40;recur &amp;#40;conj li &amp;#40;first li2&amp;#41;&amp;#41; &amp;#40;rest li2&amp;#41;&amp;#41;
          :else &amp;#40;recur li &amp;#40;rest li2&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;recur을 이용하여 li에 있는 마지막 값과 li2의 처음 값을 비교 하여 다르면 li에 추가하고 같으면 건너뛰는 방식으로 문제를 해결 하였다.&lt;/p&gt;&lt;p&gt;partition-by를 이용하는 방법도 있었는데 함수의 용도가 string 또는 collection을 순회 하면서 순서대로 같은 값 또는 같은 구조를 묶는 함수이다.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;partition-by identity &amp;#91;1 1 2&amp;#93;&amp;#41;
;; &amp;#40;&amp;#40;1 1&amp;#41; &amp;#40;2&amp;#41;&amp;#41;

&amp;#40;partition-by identity &amp;#91;1 2 1&amp;#93;&amp;#41;
;; &amp;#40;&amp;#40;1&amp;#41; &amp;#40;2&amp;#41; &amp;#40;1&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;공식 document의 예제를 변형해서 좀 더 partition-by의 용도를 확인 해봤다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;partition-by #&amp;#40;&amp;gt; 3 %&amp;#41; &amp;#91;1 2 3 4 5&amp;#93;&amp;#41;
;; &amp;#40;&amp;#40;1 2&amp;#41; &amp;#40;3 4 5&amp;#41;&amp;#41;

&amp;#40;partition-by #&amp;#40;&amp;lt; 3 %&amp;#41; &amp;#91;1 2 3 4 5&amp;#93;&amp;#41;
;; &amp;#40;&amp;#40;1 2 3&amp;#41; &amp;#40;4 5&amp;#41;&amp;#41;

&amp;#40;partition-by #&amp;#40;&amp;gt; 3 %&amp;#41; &amp;#91;1 2 3 4 5 6 7 8 9&amp;#93;&amp;#41;
;; &amp;#40;&amp;#40;1 2&amp;#41; &amp;#40;3 4 5 6 7 8 9&amp;#41;&amp;#41;

&amp;#40;partition-by #&amp;#40;= 3 %&amp;#41; &amp;#91;1 2 3 4 5 6 7 8 9&amp;#93;&amp;#41;
;; &amp;#40;&amp;#40;1 2&amp;#41; &amp;#40;3&amp;#41; &amp;#40;4 5 6 7 8 9&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;collection 값의 갯수에 따라서 묶이는 갯수가 다르다는 것을 확인 할 수 있어서 partition-all과는 동작이 다르다는 것을 알 수 있다.&lt;/p&gt;&lt;p&gt;partition-by의 원형이 되는 partition에 대해서도 테스트를 해봤다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;partition 4 &amp;#40;range 17&amp;#41;&amp;#41;
;; &amp;#40;&amp;#40;0 1 2 3&amp;#41; &amp;#40;4 5 6 7&amp;#41; &amp;#40;8 9 10 11&amp;#41; &amp;#40;12 13 14 15&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;언뜻 보기에는 partition-all과 다를바가 없어 보이는데 같은 방식으로 결과를 확인 해봤다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;partition-all 4 &amp;#40;range 17&amp;#41;&amp;#41;
;; &amp;#40;&amp;#40;0 1 2 3&amp;#41; &amp;#40;4 5 6 7&amp;#41; &amp;#40;8 9 10 11&amp;#41; &amp;#40;12 13 14 15&amp;#41; &amp;#40;16&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;마지막 값에 대해서 차이점이 있는 것을 확인 할 수 있었다. partion는 묶는 갯수에 따라서 마지막에 그 조건을 충족하지 않으면 버리지만, partition-all은 유지를 한다는 것이 차이점이다.&lt;/p&gt;
</description>
<pubDate>
Sat, 02 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-11-01-4clojure-29.html
</guid>
<link>
http://dev-happy.com/posts/2019-11-01-4clojure-29.html
</link>
<title>
4clojure - Get the Caps (29)
</title>
<description>
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;quot;HeLlO, WoRlD!&amp;quot;&amp;#41; &amp;quot;HLOWRD&amp;quot;&amp;#41;

&amp;#40;empty? &amp;#40;&amp;#95;&amp;#95; &amp;quot;nothing&amp;quot;&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;quot;$#A&amp;#40;&amp;#42;&amp;amp;987Zf&amp;quot;&amp;#41; &amp;quot;AZ&amp;quot;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Solved&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;fn &amp;#91;s&amp;#93;
  &amp;#40;apply str &amp;#40;filter #&amp;#40;Character/isUpperCase %&amp;#41; s&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;문자 중에서 대문자인 문자만 찾아서 문자열로 만드는 문제이다.  java lib를 이용하여 대문자를 필터링 하여 문제를 해결 하였다.&lt;/p&gt;&lt;p&gt;정규식을 이용하여 필터링 하는 방법도 있다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;#&amp;#40;apply str &amp;#40;re-seq #&amp;quot;&amp;#91;A-Z&amp;#93;&amp;quot; %&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
<pubDate>
Fri, 01 Nov 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-31-4clojure-28.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-31-4clojure-28.html
</link>
<title>
4clojure - Flatten a Sequence (28)
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;&amp;#40;1 2&amp;#41; 3 &amp;#91;4 &amp;#91;5 6&amp;#93;&amp;#93;&amp;#41;&amp;#41; '&amp;#40;1 2 3 4 5 6&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;quot;a&amp;quot; &amp;#91;&amp;quot;b&amp;quot;&amp;#93; &amp;quot;c&amp;quot;&amp;#93;&amp;#41; '&amp;#40;&amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot;&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;&amp;#40;&amp;#40;&amp;#40;:a&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41; '&amp;#40;:a&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;제한: flatten&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;fn myflatten &amp;#91;x&amp;#93;
  &amp;#40;cond &amp;#40;not &amp;#40;sequential? x&amp;#41;&amp;#41; &amp;#40;list x&amp;#41;
        &amp;#40;empty? x&amp;#41; nil
        :else &amp;#40;concat &amp;#40;myflatten &amp;#40;first x&amp;#41;&amp;#41; &amp;#40;myflatten &amp;#40;rest x&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;번호 순서 대로 과거에 풀었던 문제들을 다시 정리를 하면서 분석을 하고 있다. 중첩collection을 없애고 하나의 collection으로 만드는 문제인데 concat과 sequential?로 문제를 풀었다. 기본적으로 concat은 collection에 대해서 합쳐지는 것 같아서 (list)로 만들어 반환을 해주고 있다. 이때 당시에 이 문제를 풀때 위와 같은 형태의 recursive아니면 답이 없다고 생각을 했는데 clojure라면 더 나은 답이 있으리라 판단이 든다.&lt;/p&gt;
</description>
<pubDate>
Thu, 31 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-30-4clojure-27.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-30-4clojure-27.html
</link>
<title>
4clojure - Palindrome Detector (27)
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;false? &amp;#40;&amp;#95;&amp;#95; '&amp;#40;1 2 3 4 5&amp;#41;&amp;#41;&amp;#41;

&amp;#40;true? &amp;#40;&amp;#95;&amp;#95; &amp;quot;racecar&amp;quot;&amp;#41;&amp;#41;

&amp;#40;true? &amp;#40;&amp;#95;&amp;#95; &amp;#91;:foo :bar :foo&amp;#93;&amp;#41;&amp;#41;

&amp;#40;true? &amp;#40;&amp;#95;&amp;#95; '&amp;#40;1 1 3 3 1 1&amp;#41;&amp;#41;&amp;#41;

&amp;#40;false? &amp;#40;&amp;#95;&amp;#95; '&amp;#40;:a :b :c&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x&amp;#93; &amp;#40;= &amp;#40;seq x&amp;#41; &amp;#40;reverse x&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;앞으로 봐도, 뒤에서 봐도 같은 Palindrome 검증 문제 이다. 그동안은 정말 뭔가 세부적인 것에 대한 코드를 작성을 하려고 했었는데 좀 더 좋은 방법이 없을까? 고민하다가 저 값이 결국에는 뒤집었을 때 같으면 된다는 것을 알게 되었다.&lt;/p&gt;
</description>
<pubDate>
Wed, 30 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-29-4clojure-26.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-29-4clojure-26.html
</link>
<title>
4clojure - Fibonacci Sequence (26)
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 3&amp;#41; '&amp;#40;1 1 2&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 6&amp;#41; '&amp;#40;1 1 2 3 5 8&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 8&amp;#41; '&amp;#40;1 1 2 3 5 8 13 21&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x&amp;#93;
  &amp;#40;loop &amp;#91;li &amp;#91;1 1&amp;#93; cnt 2&amp;#93;
    &amp;#40;if &amp;#40;= cnt x&amp;#41; li
      &amp;#40;recur &amp;#40;conj li &amp;#40;+ &amp;#40;last li&amp;#41; &amp;#40;last &amp;#40;take &amp;#40;- &amp;#40;count li&amp;#41; 1&amp;#41; li&amp;#41;&amp;#41;&amp;#41;&amp;#41; &amp;#40;+ cnt 1&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;피보나치 수열을 구하는 문제이다. 어떻게든 문제를 풀어보겠다고 길게 써놓은 프로그램을 보고 있자니 많은 생각이 든다. 좀 더 clojure 다운 프로그램을 만들고 싶다는 것과 좀 더 공부를 더 해야겠다는 느낌에 대해 만감이 교차 한다. 결과적으로는 문제는 해결을 했지만 여기에 만족하고 싶지는 않다.&lt;/p&gt;&lt;p&gt;iterate를 가지고 문제를 해결하는 방법이 있었는데 iterate라는 함수의 특성을 이용한 방식으로 해결을 하였다 그리고 단순한 값에 대한 결과값이 당연히 그렇게 되는 것이라고 생각을 했었는데 다른 차원의 해결 방식을 보고 iterate에 대한 사용법을 다시 한번 알게 되었다.&lt;/p&gt;&lt;p&gt;단순한 값에 대한 예제이다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;iterate inc 5&amp;#41;
;; &amp;#40;5 6 7 8 9 10 11 12 13 14 15 ... n&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;위 예제만 봤을 때는 5부터 시작해서 하나씩 증가되는 것이구나 라고 생각을 했었고 별 의심을 하지 않았다 하지만 피보나치 수열에서의 사용법을 보고 경악을 하고 말았다.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;take 3 &amp;#40;iterate &amp;#40;fn &amp;#91;&amp;#91;f s&amp;#93;&amp;#93; &amp;#91;s &amp;#40;+ f s&amp;#41;&amp;#93;&amp;#41; &amp;#91;1 1&amp;#93;&amp;#41;&amp;#41;
;; &amp;#40;&amp;#91;1 1&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;2 3&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;피보나치 수열의 결과가 나오는 과정의 일부분을 가져 왔는데 여기서 왜 s의 값이 변하는가? 에 대해서 의문을 가지고 생각을 해봤고 동작에 대해서 생각지도 못한 방식에 경악을 하고 말았고 나의 얕은 지식에 한탄 하고 말았다. 왜냐하면 처음 시작 할때 [1 1]로 시작을 하고 다음 순서에서는 [1 1]을 사용을 하는 것이 아니라 [s (+ f s)]의 값을 사용을 하는 것이 iterate의 동작이라는 것을 깨달았다. 즉 두번째 반복시 [f s]의 값은 [1 2]가 되는 것이다.&lt;/p&gt;&lt;p&gt;단순한 숫자 결과의 값에 대해서도 5부터 1개씩 증가하는구나라고 생각할 수도 있겠지만 항상 &lt;strong&gt;다음 값을 출력하기 위해서 바로 이전에 값을 사용한다는 것이 iterate의 핵심&lt;/strong&gt;이라고 느꼈다.&lt;/p&gt;&lt;p&gt;보고 있자니 왠지 reduce와 동작이 비슷한 것 같다.&lt;/p&gt;&lt;p&gt;그걸 증명해 볼수 있는 예제를 만들어 봤다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;take 5 &amp;#40;iterate identity 5&amp;#41;&amp;#41;
;; &amp;#40;5 5 5 5 5&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;identity는 어떠한 계산을 하지 않고 값 그대로를 반환하는 것인데 역시나 repeat 함수와 동작이 같았다.&lt;/p&gt;&lt;p&gt;문제를 푸는 것에 의의를 두지 말고 좀 더 함수의 사용법을 알 수 있도록 나의 생각과 예제를 통해서 공부하는 것이 더 잘 할 수 있는 방법이라는 것을 깨닫게 된 계기가 되었다.&lt;/p&gt;
</description>
<pubDate>
Tue, 29 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-28-4clojure-25.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-28-4clojure-25.html
</link>
<title>
4clojure - Find the odd numbers (25)
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; #{1 2 3 4 5}&amp;#41; '&amp;#40;1 3 5&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;4 2 1 6&amp;#93;&amp;#41; '&amp;#40;1&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;2 2 4 6&amp;#93;&amp;#41; '&amp;#40;&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 1 1 3&amp;#93;&amp;#41; '&amp;#40;1 1 1 3&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;#&amp;#40;filter odd? %&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;홀수 값을 결과로 주는 프로그램을 작성하는 문제이다. filter와 odd? 함수를 사용하여 홀수 값만 필터링이 되도록 문제를 해결 하였다.&lt;/p&gt;
</description>
<pubDate>
Mon, 28 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-27-4clojure-24.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-27-4clojure-24.html
</link>
<title>
4clojure - Sum It All Up (24)
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 2 3&amp;#93;&amp;#41; 6&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#40;list 0 -2 5 5&amp;#41;&amp;#41; 8&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; #{4 2 1}&amp;#41; 7&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;0 0 -1&amp;#41;&amp;#41; -1&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;1 10 3&amp;#41;&amp;#41; 14&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x&amp;#93;
  &amp;#40;apply + x&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;값의 총 합을 계산하는 문제이다. reduce로 풀어도 되지만 apply로 하는 것이 더 간단하게 풀리므로 apply로 계산을 하였다.&lt;/p&gt;
</description>
<pubDate>
Sun, 27 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-26-4clojure-23.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-26-4clojure-23.html
</link>
<title>
4clojure - Reverse a Sequence (23)
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 2 3 4 5&amp;#93;&amp;#41; &amp;#91;5 4 3 2 1&amp;#93;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#40;sorted-set 5 7 2 7&amp;#41;&amp;#41; '&amp;#40;7 5 2&amp;#41;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;#91;1 2&amp;#93;&amp;#91;3 4&amp;#93;&amp;#91;5 6&amp;#93;&amp;#93;&amp;#41; &amp;#91;&amp;#91;5 6&amp;#93;&amp;#91;3 4&amp;#93;&amp;#91;1 2&amp;#93;&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;제한: reverse, rseq&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x&amp;#93;
  &amp;#40;reduce &amp;#40;fn &amp;#91;acc e&amp;#93; &amp;#40;conj acc e&amp;#41;&amp;#41; '&amp;#40;&amp;#41; x&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;reverse, rseq를 사용하지 않고 순서를 뒤집는 동작을 작성하는 문제 이다. 나는 reduce를 사용하여 list의 conj 동작이 들어오는 순서대로 첫번째로 추가되는 원리를 이용하여 문제를 해결 하였다 into를 이용하여 문제를 푸는 방식도 있다. &lt;/p&gt;&lt;p&gt;into의 실행 방식은 결과 collection의 형태에 따라서 다르다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;into &amp;#91;&amp;#93; &amp;#91;1 2 3 4 5&amp;#93;&amp;#41;
;; &amp;#91;1 2 3 4 5&amp;#93;

&amp;#40;into &amp;#40;&amp;#41; &amp;#91;1 2 3 4 5&amp;#93;&amp;#41;
;; &amp;#40;5 4 3 2 1&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;즉, conj + collection 의 조합이다.&lt;/p&gt;&lt;p&gt;hash-map으로는 조금 다르게도 사용  가능하다&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;into {} &amp;#91;{:a 1} {:b 2}&amp;#93;&amp;#41;
;; {:a 1 :b 2}
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
<pubDate>
Sat, 26 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-25-4clojure-22.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-25-4clojure-22.html
</link>
<title>
4clojure - Count a Sequence (22)
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;1 2 3 3 1&amp;#41;&amp;#41; 5&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;quot;Hello World&amp;quot;&amp;#41; 11&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93; &amp;#91;5 6&amp;#93;&amp;#93;&amp;#41; 3&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;13&amp;#41;&amp;#41; 1&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;:a :b :c&amp;#41;&amp;#41; 3&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;제한 : count 함수&lt;/strong&gt; &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;fn &amp;#91;x&amp;#93;
  &amp;#40;reduce &amp;#40;fn &amp;#91;acc e&amp;#93; &amp;#40;inc acc&amp;#41;&amp;#41; 0 x&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;원소의 갯수를 파악하는 문제이다 나는  reduce를 사용하여 원소를 순회하며 acc를 한개씩 증가시키는 방법으로 문제를 해결 하였다.&lt;/p&gt;&lt;p&gt;solution을 보니 or 또는 do를 사용하여 문제를 해결한 사람들도 있었다. or은 false인 경우를 제외하고 무조건 첫번째 표현식의 결과 값을 반환 한다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;or &amp;#40;inc 0&amp;#41; :a&amp;#41;
;; 1
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;위 표현식을 보면 :a는 출력을 하지 않는다는 것이다.&lt;/p&gt;&lt;p&gt;do는 표현식을 순서대로 실행하는 함수이다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;do &amp;#40;print &amp;quot;Somthing&amp;quot;&amp;#41;
	  &amp;#40;print &amp;quot;this&amp;quot;&amp;#41;&amp;#41;
;; Somthing
;; this
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
<pubDate>
Fri, 25 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-24-4clojure-21.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-24-4clojure-21.html
</link>
<title>
4clojure - Nth Element (21)
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;4 5 6 7&amp;#41; 2&amp;#41; 6&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;:a :b :c&amp;#93; 0&amp;#41; :a&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 2 3 4&amp;#93; 1&amp;#41; 2&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;&amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93; &amp;#91;5 6&amp;#93;&amp;#41; 2&amp;#41; &amp;#91;5 6&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;제한: nth&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;fn mynth &amp;#91;x cnt&amp;#93; 
	&amp;#40;if &amp;#40;= cnt 0&amp;#41; &amp;#40;first x&amp;#41; 
	&amp;#40;mynth &amp;#40;rest x&amp;#41; &amp;#40;- cnt 1&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;풀었던 문제들을 다시 정리를 하면서 좀 더 짧은 방법을 정리를 하는 것이 맞는 것인가를 생각을 하게되었지만 지금 나의 현재 실력을 보는 것도 중요하다는 생각이 들었다. 문제를 풀고 나서 해답을 보는데 왜 나는 저런 방법을 생각하지 못했을까?를 생각하게 되는 계기가 되는 것 같다. recursive를 하면서 index를 조회하여 값을 가져오는 방법으로 문제를 풀었다.&lt;/p&gt;&lt;p&gt;solution에서는 drop을 사용하여 문제를 해결하는 방식이 있었다.  drop의 용도는 첫번째부터 갯수만큼 버리는 함수이다.&lt;pre&gt;&lt;code class=&quot;clj&quot;&gt;&amp;#40;drop 2 '&amp;#40;4 5 6 7&amp;#41;&amp;#41;
;; &amp;#40;6 7&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
<pubDate>
Thu, 24 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-23-4clojure-20.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-23-4clojure-20.html
</link>
<title>
4clojure - Penultimate Element (20)
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#40;list 1 2 3 4 5&amp;#41;&amp;#41; 4&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot;&amp;#93;&amp;#41; &amp;quot;b&amp;quot;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;#91;1 2&amp;#93; &amp;#91;3 4&amp;#93;&amp;#93;&amp;#41; &amp;#91;1 2&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;#&amp;#40;second &amp;#40;reverse %&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;19번 문제와 비슷한 문제 이다. 언뜻 보기에는 각각 다른 위치의 원소를 가져오는 문제 처럼 보여서 헷갈렸는데 결국에는 뒤집어서 두번째 원소를 가져오는 문제라는 사실을 깨닫고 풀게 된 문제이다. 앞으로 이런 문제들이 많을 텐데 생각의 확장이 필요 한 것 같다.&lt;/p&gt;
</description>
<pubDate>
Wed, 23 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-22-4clojure-19.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-22-4clojure-19.html
</link>
<title>
4clojure - Last Element (19)
</title>
<description>
&lt;p&gt;제한 함수 : last 함수&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;1 2 3 4 5&amp;#93;&amp;#41; 5&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; '&amp;#40;5 4 3&amp;#41;&amp;#41; 3&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;#91;&amp;quot;b&amp;quot; &amp;quot;c&amp;quot; &amp;quot;d&amp;quot;&amp;#93;&amp;#41; &amp;quot;d&amp;quot;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;#&amp;#40;first &amp;#40;reverse %&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;처음으로 제한을 두는 함수가 나왔다 last를 사용하지 않고 끝에 값을 가져오는 문제 이다. 많은 방법들이 있겠지만 collection 을 뒤집어서 첫번째 원소를 가져오는 방법이 가장 간단하고 생각하기 쉬운 방법으로 보인다.&lt;/p&gt;
</description>
<pubDate>
Tue, 22 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-21-4clojure-18.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-21-4clojure-18.html
</link>
<title>
4clojure 18
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;filter #&amp;#40;&amp;gt; % 5&amp;#41; '&amp;#40;3 4 5 6 7&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;'&amp;#40;6 7&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;filter에 동작에 관한 문제 이다. filter는 비교군에 대한 결과 값을 collection으로 주는 함수 이다. 따라서 결과는 ‘(6 7)이 된다.&lt;/p&gt;
</description>
<pubDate>
Mon, 21 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-20-4clojure-17.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-20-4clojure-17.html
</link>
<title>
4clojure 17
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;map #&amp;#40;+ % 5&amp;#41; '&amp;#40;1 2 3&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;'&amp;#40;6 7 8&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;map은 기본적으로 for구문과 유사하지만 collection으로 반환한다는 특성을 가지고 있다. 내부의 +5를 하는 익명 함수를 거쳐서 나오는 답은 ‘(6 7 8) 이다.&lt;/p&gt;
</description>
<pubDate>
Sun, 20 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-19-4clojure-16.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-19-4clojure-16.html
</link>
<title>
4clojure 16
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;quot;Dave&amp;quot;&amp;#41; &amp;quot;Hello, Dave!&amp;quot;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;quot;Jenn&amp;quot;&amp;#41; &amp;quot;Hello, Jenn!&amp;quot;&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; &amp;quot;Rhea&amp;quot;&amp;#41; &amp;quot;Hello, Rhea!&amp;quot;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;#&amp;#40;str &amp;quot;Hello, &amp;quot; % &amp;quot;!&amp;quot;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;15번 문제와 비슷하게 함수의 실행에 대한 문제 및 string 활용 문제 이다. clojure에서는 string의 조합을 할 때 str 함수를 사용하고 어떠한 기호도 붙이지 않고 띄어쓰기로 문장의 결합이 가능하다. &lt;/p&gt;
</description>
<pubDate>
Sat, 19 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-18-4clojure-15.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-18-4clojure-15.html
</link>
<title>
4clojure 15
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 2&amp;#41; 4&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 3&amp;#41; 6&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 11&amp;#41; 22&amp;#41;

&amp;#40;= &amp;#40;&amp;#95;&amp;#95; 7&amp;#41; 14&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;#&amp;#40;&amp;#42; % 2&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;문제들의 값은 기본적으로 2 * ? 의 결과를 나타내주고 있다. 그래서 clojure에서는 함수를 만들고 바로 실행을 할 수 있는 방법으로 표현을 했다. &lt;/p&gt;
</description>
<pubDate>
Fri, 18 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-17-4clojure-14.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-17-4clojure-14.html
</link>
<title>
4clojure 14
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;&amp;#40;fn add-five &amp;#91;x&amp;#93; &amp;#40;+ x 5&amp;#41;&amp;#41; 3&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;&amp;#40;fn &amp;#91;x&amp;#93; &amp;#40;+ x 5&amp;#41;&amp;#41; 3&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;#&amp;#40;+ % 5&amp;#41; 3&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;&amp;#40;partial + 5&amp;#41; 3&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;clojure에서는 기본적으로 익명 함수를 만드는 방법이 2가지가 있다. fn으로 시작하는 방법, # 으로 시작하는 방법, 2가지가 있고 partial은 미리 공통된 수식을 정의 하는 함수로써 공통된 작업을 미리 정의할 때 사용하는 함수이다. 그래서 8일때 4개의 등식은 성립한다.&lt;/p&gt;
</description>
<pubDate>
Thu, 17 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-16-4clojure-13.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-16-4clojure-13.html
</link>
<title>
4clojure 13
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;rest &amp;#91;10 20 30 40&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#91;20 30 40&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;clojure에서는 lisp에서 제공 하는 함수들을 기본 제공 한다 rest도 마찬가지로 lisp에서 제공하는 기능 그대로의 역할을 한다. rest는 처음 값을 뺀 나머지 값이므로 [20 30 40] 이다.&lt;/p&gt;
</description>
<pubDate>
Wed, 16 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-15-4clojure-12.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-15-4clojure-12.html
</link>
<title>
4clojure 12
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;first '&amp;#40;3 2 1&amp;#41;&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;second &amp;#91;2 3 4&amp;#93;&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;last &amp;#40;list 1 2 3&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;clojure에서는 원소를 접근 할 수 있는 squense 함수들을 제공 한다. first, second, last 단어 그대로 해석을 하면 되고 첫번째, 두번째, 마지막 원소를 가져온다 그러므로 3의 값이 성립한다.&lt;/p&gt;
</description>
<pubDate>
Tue, 15 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-14-4clojure-11.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-14-4clojure-11.html
</link>
<title>
4clojure 11
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= {:a 1, :b 2, :c 3} &amp;#40;conj {:a 1} &amp;#95;&amp;#95; &amp;#91;:c 3&amp;#93;&amp;#41;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#91;:b 2&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;기본적으로 hash-map에서의 conj 사용은 하나의 hash-map으로 합치는 용도로 사용되는 것 같다. vector로 하는 것 뿐만 아니라 {}로도 가능하다 하지만 ‘()로는 되지 않는 것으로 확인 되었다.&lt;/p&gt;
</description>
<pubDate>
Mon, 14 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-13-4clojure-10.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-13-4clojure-10.html
</link>
<title>
4clojure 10
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;&amp;#40;hash-map :a 10, :b 20, :c 30&amp;#41; :b&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;:b {:a 10, :b 20, :c 30}&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;20
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;python의 dictionary 자료형과 동일한 역할을 한다 clojure에서는 hash-map이라는 용어를 사용하고 만드는 방법은 위와 같이 {}에 :a 형태의 key와 value를 추가하여 생성한다. 위 문제에서는 :b key의 값을 가져오는 방법을 보여주고 있다. ({} :b)의 형태, (:b {})의 형태 모두 :b의 값을 가져오는 역할을 한다. 답은 20이다.&lt;/p&gt;
</description>
<pubDate>
Sun, 13 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-12-4clojure-09.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-12-4clojure-09.html
</link>
<title>
4clojure 09
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= #{1 2 3 4} &amp;#40;conj #{1 4 3} &amp;#95;&amp;#95;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;집합은 기본적으로 순서를 가지지 않는다. 순서가 달라도 같은 집합으로 인식을 하고, conj 함수의 동작은 마지막에 값을 추가한다. 따라서 2 값으면 성립을 한다.&lt;/p&gt;
</description>
<pubDate>
Sat, 12 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-11-4clojure-08.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-11-4clojure-08.html
</link>
<title>
problem 08
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;set '&amp;#40;:a :a :b :c :c :c :c :d :d&amp;#41;&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;clojure.set/union #{:a :b :c} #{:b :c :d}&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;#{:a :b :c :d}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;set이라는 자료형은 집합이다. 수학의 집합 관련 연산은 무엇이든 가능하며, 중복된 값을 제거 하는 역할을 가지고 있다. union은 합집합의 기능을 한다. 집합기호는 기본적으로#{} 형태로 나타내며 # {:a :b :c :d} 로 성립한다.&lt;/p&gt;
</description>
<pubDate>
Fri, 11 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-10-4clojure-07.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-10-4clojure-07.html
</link>
<title>
problem 07
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;conj &amp;#91;1 2 3&amp;#93; 4&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;conj &amp;#91;1 2&amp;#93; 3 4&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#91;1 2 3 4&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;vector의 conj는 list와 다르게 마지막에 값을 추가한다 그러므로 [1 2 3 4] 이다.&lt;/p&gt;
</description>
<pubDate>
Thu, 10 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-09-4clojure-06.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-09-4clojure-06.html
</link>
<title>
problem 06
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#91;&amp;#95;&amp;#95;&amp;#93; &amp;#40;list :a :b :c&amp;#41; &amp;#40;vec '&amp;#40;:a :b :c&amp;#41;&amp;#41; &amp;#40;vector :a :b :c&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:a :b :c
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; vector 자료형이다. vector를 생성하는 방법에 대해서 보여주고 있다. 중간에 vec은 list 자료형을 받으면 vector로 변환하는 함수이다. 기본적으로 내용이 같으면 vector, list는 서로 같다 그러므로 :a :b :c이면 성립힌다.&lt;/p&gt;
</description>
<pubDate>
Wed, 09 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-08-4clojure-05.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-08-4clojure-05.html
</link>
<title>
problem 05
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;conj '&amp;#40;2 3 4&amp;#41; 1&amp;#41;&amp;#41;

&amp;#40;= &amp;#95;&amp;#95; &amp;#40;conj '&amp;#40;3 4&amp;#41; 2 1&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;'&amp;#40;1 2 3 4&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;처음으로 테스트를 통과해야하는 문제가 2개가 되었다. conj는 list 자료형인 경우 앞에 값을 추가를 한다, 2개가 있는 경우 앞에 값부터 차례로 값을 앞으로 추가를 한다. stack이라고 생각하면 쉬울 것 같다. 그러므로’(1 2 3 4)이면 등호를 만족 한다.&lt;/p&gt;
</description>
<pubDate>
Tue, 08 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-07-4clojure-04.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-07-4clojure-04.html
</link>
<title>
problem 04
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;list &amp;#95;&amp;#95;&amp;#41; '&amp;#40;:a :b :c&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:a :b :c
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;clojure에서 리스트를 만드는 방법이 여러가지 가 있는데 ‘()로 만드는 방법 (list)로 만드는 방법이 있다. 위 문제는 두가지 방법을 사용하였고 list안에 만족하는 답을 넣어주면 된다. 답은 :a :b :c 이다.&lt;/p&gt;
</description>
<pubDate>
Mon, 07 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-06-4clojure-03.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-06-4clojure-03.html
</link>
<title>
problem 03
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#95;&amp;#95; &amp;#40;.toUpperCase &amp;quot;hello world&amp;quot;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;quot;HELLO WORLD&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;clojure에서는 기본적으로 자바의 라이브러리를 사용할 수 있다. 마찬가지로 string에 대한 함수를 호출 할 수 있는데 자바와는 반대로 위와같은 방법으로 호출을 하여 사용 할 수 있다. “HELLO WORLD”로 하면 성립이 된다.&lt;/p&gt;
</description>
<pubDate>
Sun, 06 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-05-4clojure-02.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-05-4clojure-02.html
</link>
<title>
problem 02
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;- 10 &amp;#40;&amp;#42; 2 3&amp;#41;&amp;#41; &amp;#95;&amp;#95;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;중간의 계산식에 대한 답을 넣으면 된다 기본적으로 lisp은 안에서 부터 밖으로 계산이 되므로 풀어서 쓴다면 10 - (2 * 3)의 계산 결과가 된다. 4로 하면 등호가 성립이 된다.&lt;/p&gt;
</description>
<pubDate>
Sat, 05 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-04-4clojure-01.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-04-4clojure-01.html
</link>
<title>
problem 01
</title>
<description>
&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;= &amp;#40;&amp;#95;&amp;#95; true&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;__ 안에 어떤 값을 넣어야 =를 만족 할수 있는지 부터가 4clojure의 시작이다 true를 넣으면 값이 성립 한다.&lt;/p&gt;
</description>
<pubDate>
Fri, 04 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-03-4clojure-start.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-03-4clojure-start.html
</link>
<title>
4clojure 정리
</title>
<description>
&lt;p&gt;clojure 언어를 좋아한다고 해놓고선 아무런 공부의 기록이 없다는 것이 말이 안된다는 생각이 들었다.&lt;/p&gt;&lt;p&gt;그래서 기존에 했던 내용들을 복습을 할 겸 1개씩 정리를 하려고 한다.&lt;/p&gt;&lt;p&gt;쉬운 내용이면 쉽게 가고 좀 생각을 해야할 내용이면 생각 정리와 동시에 시도했던 내용들을 정리를 한다.&lt;/p&gt;
</description>
<pubDate>
Thu, 03 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-02-stop-retention.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-02-stop-retention.html
</link>
<title>
리텐션이 낮고 사용자가 감소 또는 유지된다는 것은?
</title>
<description>
&lt;p&gt;마케팅비용을 사용하면서 사용자의 관심을 단기간에 끌긴 하지만 단기간이라고 한다면 증가세가 아니라면 난 제품에 문제가 있다고 생각한다 제품이 좋고, 나의 불편한점을 해결한다면 안쓸이유가 없기 때문이다 사용자는 자신의 불편함을 해결해 주는 제품에 돈을 지불한다&lt;/p&gt;&lt;p&gt;지금 리텐션이 낮고 사용자가 감소 또는 유지가 된다는 것은 내부 직원이 아무런 활동을 하지 않아서가 아니라 애초에 지금의 앱이 사용자의 문제를 해결하지 못한다는 반증이 될 수도 있다 사용자에게 별 필요가 없는 제품이라는 뜻이다 &lt;/p&gt;&lt;p&gt;단기간에 사용자의 리텐션을 올리기 위해 푸시를 자주 보내는 것이 맞는 것인가? 아니면 어떤 불편함을 해결하기 위해서 고민을 하는 것이 맞는 것인가?   &lt;/p&gt;&lt;p&gt;둘다 하는 것이 맞겠지만 리소스는 한정이 되어 있으므로 한정된 리소스 안에서 절충안은 필요하다고 생각한다.&lt;/p&gt;
</description>
<pubDate>
Wed, 02 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-10-01-think-in-box.html
</guid>
<link>
http://dev-happy.com/posts/2019-10-01-think-in-box.html
</link>
<title>
틀안에서 생각한다는 것의 의미
</title>
<description>
&lt;p&gt;혁신이라고 하는 것은 아무 것도 없는 것에서 생기지 않는다고 생각한다 현재의 환경에서 어떻게 한발 더 나아지는지를 고민하는 것이 혁신이라고 생각하고 현재의 리소스를 어떻게 최대한 활용을 할 것인지가 혁신이라고 생각한다&lt;/p&gt;&lt;p&gt;보통은 무엇이 더 나아지면 할 수 있는데 무엇이 더 나아지면 좋아지는데 라는 생각들을 많이 하곤한다 근데 그런 생각들이 오히려 더 나아질 수 있는 것을 방해하는 것이라고 생각 한다&lt;/p&gt;&lt;p&gt;어떠한 단점들만 말하는 것 보다는 그 것들을 해결하기 위해서 지금 내가 할 수 있는 일을 생각하는 것이 더 나아지는 방향이라고 생각한다&lt;/p&gt;
</description>
<pubDate>
Tue, 01 Oct 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-09-30-think-extend.html
</guid>
<link>
http://dev-happy.com/posts/2019-09-30-think-extend.html
</link>
<title>
확장성이라는 것에 대한 생각
</title>
<description>
&lt;p&gt;과자를 하나 사러 동네 슈퍼를 갔다가 집으로 돌아가는 중이다 집에서 어머니가 오는길에 고기를 사오라고 한다면? 어떠한 반응을 보여야 할까? 왜 지금 얘기하는지 화내야 할까? 아니면 첨부터 동네 슈퍼를 간 내 탓일까?&lt;/p&gt;&lt;p&gt;어떠한 경우라도 상황이라는 것이 내가 원하는데로만 생각한데로만 될순 없다고 생각한다&lt;/p&gt;&lt;p&gt;그렇다고 모든 경우의 수를 고려해서 할 수도 없다 그렇다면 어떻게 해야할까?&lt;/p&gt;&lt;p&gt;마음으로라도 상황이 수시로 변한다는 것을 인정을 하면서 대응을 하는 것이 맞다고 생각한다&lt;/p&gt;&lt;p&gt;단적이었지만 개발하는 상황에서도 일어날 수 있는 일이다 확정적으로 무언가를 항상 할 수는 없다 시시때때로 변화하는 환경에 내가 잘 대응할 수 있도록 만드는 것이 중요한 것 같다&lt;/p&gt;
</description>
<pubDate>
Mon, 30 Sep 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-09-27-how-db-select.html
</guid>
<link>
http://dev-happy.com/posts/2019-09-27-how-db-select.html
</link>
<title>
RDB select에 대한 고찰
</title>
<description>
&lt;p&gt;개발을 하다보면 rdb는 필수로 사용을 하게 된다 &lt;/p&gt;&lt;p&gt;그렇지만 rdb에 있는데이터의 구조를 확장성 있게 사용한다는 것은 또다른 어려움이 있다고 생각한다&lt;/p&gt;&lt;p&gt;rdb 구조를 잘 설계하면 확장성있게 사용 가능한가?라는 질문에는 아니오라고 얘기하고 싶다 그 이유는 2차원으로 사용하는 rdb의 특성상 원하는 구조로 다시 바꾸기란 쉽지만은 않기때문이다&lt;/p&gt;&lt;p&gt;원하는 데이터를 전송할때도 전송할 데이터에 대한 구조만 작성을 하는 것이 확장성이 있을까 하면 아니오이고 필히 수정 또는 확장을 요구하는 현상이 반드시 일어난다고 생각한다&lt;/p&gt;&lt;p&gt;내가 하고 싶은 것은 테이블 전체의 데이터 구조들을 정의 해놓고 select를 하고 원하는 데이터만 선택적으로 전송한다면 변화에는 유용하리라 생각한다&lt;/p&gt;&lt;p&gt;아직 그렇게 작성을 해보진 않아서 얼마나 속도에 영향이 있을지는 모르겠지만 시도해볼만 하다고 생각한다&lt;/p&gt;&lt;p&gt;다시 생각을 해보니 너무 rdb 설계에 의존을 하는 것은 않좋다는 생각이 들었다. db를 먼저 설계 하고 클래스를 설계를 하게 되니 확장성이 안그래도 없는데 더 없어졌다는 생각이 들었고 db를 설계하기 전에 class를 설계하는 습관이 필요하다는 생각이 들었다. 그래야 test 코드도 원하는데로 만들수 있고, 확장 및 변경에 용이하리라 생각한다.&lt;/p&gt;&lt;p&gt;db 보다는 domain이 중요하다.&lt;/p&gt;
</description>
<pubDate>
Fri, 27 Sep 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-09-26-sql-vs-java.html
</guid>
<link>
http://dev-happy.com/posts/2019-09-26-sql-vs-java.html
</link>
<title>
SQL query VS java (프로그래밍 언어)
</title>
<description>
&lt;p&gt;java는 알고 있었지만 server 개발을 하면서 query 작성만으로 충분하다고 생각 했었다. 하지만 요즘은 java 로직을 어떻게 작성을 해야할지 더 신경을 쓰게 된다.&lt;/p&gt;&lt;p&gt;매일매일이 다른 변화를 대응을 해야하다보니 query만으로는 한계를 많이 느꼈고 확장성과 유연함을 위해서는 구조 설계 및 아키텍처 설계 능력의 필요성을 자연스럽게 느끼게 되었다.&lt;/p&gt;&lt;p&gt;그래서 최소한으로 db 데이터를 가져 오고,  java 로직에서 더 가공을 할 수 있는 쪽으로 server는 점점 발전을 해 나가고 있다.&lt;/p&gt;&lt;p&gt;프로그래밍의 발전 성향으로 봤을 때도 query쪽으로, db쪽으로 발전을 하기 보다는 server 로직 단에서 더 발전을 하고 있음을 몸소 느끼는 중이다.&lt;/p&gt;&lt;p&gt;Server 부하 관리를 로드 밸런싱이 생겼고, 똑같은 Server를 빠르게 생성을 하기 위해서 docker 가 탄생을 하였다.&lt;/p&gt;&lt;p&gt;Db 부하가 발생하면? db를 추가하는 것은 어려운 기술을 필요로 한다.(요즘에는 AWS에서 손쉽게 읽기 전용으로 생성이 가능하지만 Server의 확장 처럼 유연하게 확장하기는 어렵다고 생각한다.)&lt;/p&gt;&lt;p&gt;query 작성 보다는 orm 쪽으로 언어의 특성에 맞게 다양하게 발전 중이라고 생각한다.&lt;/p&gt;&lt;p&gt;query는 정적이다. 동적으로 무언가를 하기가 어렵고, 서비스를 하는 입장에서 확장을 위해서라면 아키텍처 설계는 필수라는 것을 몸소 체감하고 있다.&lt;/p&gt;&lt;p&gt;한번 만들고 유지보수를 하지 않는 프로젝트라고 한다면 단일로 query를 작성하는게 나을수도 있지만 비즈니스, 서비스를 하는 회사라면 빠른 변화의 대응을 위해서는 로직 작성이 우선이 되어야 한다.&lt;/p&gt;&lt;p&gt;왜 서비스를 하는 회사들이 면접을 볼때 디자인 패턴이니, 구현상의 어려움이니 그런 질문들을 하는 이유가 왜 하는지 조금은 알 것 같다.&lt;/p&gt;&lt;p&gt;그때까지 난 query로 모든 것을 해결 하였기 때문에 어려움이 많이 없었다고 생각한다.&lt;/p&gt;&lt;p&gt;지금도 상품의 Sort 로직 작성을 생각하면서 좀 더 나은 방법이 없는지 이런 문제들은 어떻게 해결을 해야하는게 좋은지 더 나은 방법을 찾으려고 하는 것 자체가 많은 발전이라고 생각한다.(현재 서비스하는 시스템에서는 query로 해결 되어 있지만 확장성은 없다)&lt;/p&gt;&lt;p&gt;10년 이상 프로그래밍을 하였지만 아직 더 가야할 길이 먼거 같다.&lt;/p&gt;
</description>
<pubDate>
Thu, 26 Sep 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-09-25-python-reduce.html
</guid>
<link>
http://dev-happy.com/posts/2019-09-25-python-reduce.html
</link>
<title>
Python3 reduce 사용
</title>
<description>
&lt;p&gt;Python에서 어떠한 문제를 해결 하기 위해서 reduce를 사용을 하게 되었다.&lt;/p&gt;&lt;p&gt;예제에서는 list안에서 원하는 인덱스 얻기 위한 상황에서 사용을 하게 되었다. 보통은 아래와 같은 코드로 작성을 하게된다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;python
select&amp;#95;index = 0
for index, value in enumerate&amp;#40;&amp;#91;1,2,3,4,5,6,7,8&amp;#93;&amp;#41;:
	if value == 5:
		select&amp;#95;index = index
		break
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;조금 뭔가 작위적인 코드가 된거 같긴 한데 위와 비슷한 알고리즘으로 처음에 생각을 하게 되고, 개발자라면 누구나 쉽게 생각할 수 있는 코드의 구조라고 생각을 한다.&lt;/p&gt;&lt;p&gt;하지만 파이썬을 사용을 하다보니 좀 더 쉬운, 간단한 방법은 없을까?라고 생각을 하게 되었고 2번째는 아래와 같은 코드를 생각을 하게 되었다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;python
#python3에서는 아래코드 import
from functools import reduce

index = reduce&amp;#40;lambda acc, x: x if x&amp;#91;1&amp;#93; == 5 else acc, enumerate&amp;#40;&amp;#91;1,2,3,4,5,6,7,8&amp;#93;&amp;#41;&amp;#41;

index&amp;#91;0&amp;#93; # index 값 추출

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;clojure를 하다보니 reduce라는 함수는 알고 있었고 사용법이 무궁무진 하다는 것을 알고 있었기 때문에 혹시나  python에서도 이런 방법으로 할 수 있지 않을까?라는 생각을 하게 되었고 적용을 하였다.&lt;/p&gt;&lt;p&gt;설명을 한다면 lambda안에서 acc에 누적 값을 저장을 하는 방식인데 보통은 reduce를 아래와 같은 방법으로 사용을 한다.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;python
#python3에서는 아래코드 import
from functools import reduce

sum = reduce&amp;#40;lambda acc, x: acc+x, &amp;#91;1,2,3,4,5,6,7,8&amp;#93;&amp;#41;
#sum의 값은 36
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;어차피 acc에는 list가 순회 할때까지 조건에 맞는 값을 유지 할 수 있을 것 같아서 사용을 하게 되었다.&lt;/p&gt;&lt;p&gt;지금은 리팩토링을 하다보니 reduce 코드보다는 dictionary로 변경을 하여 사용하고 있지만 reduce의 기록을 위해서 남겨둔다.&lt;/p&gt;
</description>
<pubDate>
Wed, 25 Sep 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2019-09-24-experience-python.html
</guid>
<link>
http://dev-happy.com/posts/2019-09-24-experience-python.html
</link>
<title>
Python을 2년 사용해 보고
</title>
<description>
&lt;p&gt;2016년에 본격적으로 사용을 해서 최근까지 웹, 스크립트로 사용을 하고 있다. 처음에는 문법적인 어색함이 커서 적응을 하기 힘들었으나 하면 할 수록 생산성이 올라가는데 일조를 한다는 것을 알게 되었다.&lt;/p&gt;&lt;p&gt;특히, 지금 회사에서 본격적으로 귀찮은 업무들을 모두 Python으로 사용을 하면서 그 매력을 더 잘 느낄 수 있었다.&lt;/p&gt;&lt;p&gt;쉬운 문법 덕분인지는 모르겠지만 무언가 생각을 바로바로 구현을 해보고 테스트를 해보는 것이 장점으로 다가 왔던 것 같다.&lt;/p&gt;&lt;p&gt;무엇보다 더 짧은 방법 더 간결한 방법을 생각을 하게 된다는 것에서 매력을 느꼈다. 사실 다른 언어도 마찬가지일 수 있겠지만 고착화된 언어를 사용하게 되다보면 문법적인 한계로 인하여  더 개선을 해야한다는 의지가 생기진 않는 것 같다.&lt;/p&gt;
</description>
<pubDate>
Tue, 24 Sep 2019 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2018-02-07-why-clojure-blog.html
</guid>
<link>
http://dev-happy.com/posts/2018-02-07-why-clojure-blog.html
</link>
<title>
왜 클로저로 블로그를 만들었는가?
</title>
<description>
&lt;h3 id=&quot;들어가며&quot;&gt;들어가며&lt;/h3&gt;&lt;p&gt; 클로저를 선택하게 된 이유와 왜 클로저로 블로그를 만들었는지에 대한 설명을 한다.&lt;/p&gt;&lt;h3 id=&quot;클로저를&amp;#95;선택하게&amp;#95;된&amp;#95;이유&quot;&gt;클로저를 선택하게 된 이유&lt;/h3&gt;&lt;p&gt; 흔하디 흔한 함수형 프로그래밍과 불변 등등의 특징은 인터넷으로 찾아보면 다 나오므로 개인적으로 선택을 하게 된 이유를 작성을 한다.&lt;br /&gt;&lt;/p&gt;&lt;p&gt; 처음 프로그래밍을 시작하게 되었을 때 C, C++로 하였는데 그 때부터 왜 내 생각을 바로 표현을 할 수가 없는지에 대한 의문을 품게 되었다.&lt;/p&gt;&lt;p&gt; 그런 의문은 업무에 시달리고 바쁘다 보니 잊어버리고 살았었는데 scheme을 접하게 되면서 다시 그 의문들을 다시 생각하게 되었다.&lt;br /&gt;&lt;/p&gt;&lt;p&gt; 물론 완벽하게 내 생각을 표현을 그대로 할 수는 없겠지만 추상성이 높다보니 그래도 만족을 하면서 공부를 하게 되었다.&lt;br /&gt;&lt;/p&gt;&lt;p&gt; 하지만 수 없이 많은 라이브러리들을 바로 사용을 할 수가 없었고 그래서 JAVA와 연동이 가능한 clojure를 선택을 하게 되었다.&lt;/p&gt;&lt;p&gt; 이 글을 쓰고 있는 시점의 나는 아직 LISP 풋내기에 불과 하지만 언젠가는 내 것을 만들 것이라는 희망을 품고 있다.&lt;/p&gt;&lt;p&gt; 컴퓨터 내부가 어떻게 돌아가는지에 대한 생각에 빠져서 살다보니 어느순간 내 생각은 컴퓨터화가 되어 가고 있다는 것을 느끼게 되었다.&lt;/p&gt;&lt;p&gt; 그래서 좀 더 고차원적으로 생각을 하고 싶어서 LISP을 공부를 하는 이유도 있다.&lt;/p&gt;&lt;p&gt; 다른 사람들은 어떻게 생각 할 지는 잘 모르겠지만 개인적인 생각으로 그렇게 느끼게 되어 정리를 하고 싶어서 작성을 하였다.&lt;/p&gt;&lt;h3 id=&quot;클로저로&amp;#95;블로그를&amp;#95;만든&amp;#95;이유&quot;&gt;클로저로 블로그를 만든 이유&lt;/h3&gt;&lt;p&gt; 업무 외의 시간에 무언가 스스로 만들고 싶어서라는 이유가 크다.&lt;br /&gt;  물론 framework는 내가 만든건 아니지만 워낙 작다보니 추가적인 기능들을 추가하기가 쉽다는 것도 장점일 수 있을 것 같다.&lt;/p&gt;
</description>
<pubDate>
Wed, 07 Feb 2018 00:00:00 +0900
</pubDate>
</item>
<item>
<guid>
http://dev-happy.com/posts/2018-01-27-first-post.html
</guid>
<link>
http://dev-happy.com/posts/2018-01-27-first-post.html
</link>
<title>
클로저로 된 블로그 생성
</title>
<description>
&lt;h3 id=&quot;블로그에&amp;#95;작성을&amp;#95;할&amp;#95;글&quot;&gt;블로그에 작성을 할 글&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;새롭게 알게 된 내용 정리&lt;/li&gt;&lt;li&gt;독서 감상문&lt;/li&gt;&lt;li&gt;알고 있는 내용 정리&lt;/li&gt;&lt;li&gt;블로그 테마 수정&lt;/li&gt;&lt;li&gt;알고리즘 문제 풀이&lt;/li&gt;&lt;li&gt;블로그 코드 수정하여 기능 추가&lt;/li&gt;&lt;li&gt;이력서 정리&lt;/li&gt;&lt;li&gt;등등&lt;/li&gt;&lt;/ul&gt;
</description>
<pubDate>
Sat, 27 Jan 2018 00:00:00 +0900
</pubDate>
</item>
</channel>
</rss>
